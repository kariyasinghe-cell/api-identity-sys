name: Export WSO2 APIs to GitHub Release

on:
  workflow_call:
    inputs:
      includeAPIs:
        description: "Comma-separated list of APIM APIs to include"
        required: true
        type: string
      environment:
        description: "Environment name configured in APIM"
        required: true
        type: string
      version:
        description: "Release version tag"
        required: true
        type: string

jobs:

  # ============================
  # 1. Install required tooling
  # ============================
  setup-tools:
    runs-on: [self-hosted, linux]
    outputs:
      apictl-path: ${{ steps.locate-apictl.outputs.apictl_path }}

    steps:
      - uses: actions/checkout@v4

      - name: Install apictl
        id: locate-apictl
        run: |
          WORK_DIR="$RUNNER_WORKSPACE/apictl-4.1.6"
          mkdir -p "$WORK_DIR"

          if [ ! -f "$WORK_DIR/apictl/apictl" ]; then
            cd "$WORK_DIR"
            wget "https://github.com/wso2/product-apim-tooling/releases/download/v4.1.6/apictl-4.1.6-linux-amd64.tar.gz"
            tar -xzf apictl-4.1.6-linux-amd64.tar.gz
          fi

          chmod +x "$WORK_DIR/apictl/apictl"
          echo "$WORK_DIR/apictl" >> $GITHUB_PATH
          echo "apictl_path=$WORK_DIR/apictl" >> $GITHUB_OUTPUT

      - name: Install GitHub CLI
        run: |
          INSTALL_DIR="${RUNNER_WORKSPACE}/gh-cli"
          mkdir -p "$INSTALL_DIR"
          curl -sSL https://github.com/cli/cli/releases/download/v2.79.0/gh_2.79.0_linux_amd64.tar.gz -o gh.tar.gz
          tar -xzf gh.tar.gz -C "$INSTALL_DIR" --strip-components=1
          echo "$INSTALL_DIR/bin" >> $GITHUB_PATH

      - name: Verify GH CLI
        run: gh --version

  # =======================================
  # 2. Add APIM environment + login
  # =======================================
  apim-login:
    runs-on: [self-hosted, linux]
    needs: setup-tools
    env:
      APIM_ENV: ${{ inputs.environment }}

    steps:
      - uses: actions/checkout@v4

      - name: Add Environment
        run: |
          case "${{ inputs.environment }}" in
            "Dev") APIM_ENV_URL=${{ secrets.APIM_ENV_URL_DEV }} ;;
            "SIT") APIM_ENV_URL=${{ secrets.APIM_ENV_URL_SIT }} ;;
            "SIT-sandbox") APIM_ENV_URL=${{ secrets.APIM_ENV_URL_SIT_SANDBOX }} ;;
            "UAT-node-1") APIM_ENV_URL=${{ secrets.APIM_ENV_URL_UAT_NODE_1 }} ;;
            "UAT-node-2") APIM_ENV_URL=${{ secrets.APIM_ENV_URL_UAT_NODE_2 }} ;;
            "STG-sandbox") APIM_ENV_URL=${{ secrets.APIM_ENV_URL_STG_SANDBOX }} ;;
            *) echo "Unknown environment"; exit 1 ;;
          esac

          if apictl get envs | grep -q "${APIM_ENV}"; then
            echo "Environment already exists."
          else
            apictl add env "$APIM_ENV" --apim https://$APIM_ENV_URL
          fi

      - name: Login to APIM
        run: |
          apictl set --http-request-timeout 300000

          case "${{ inputs.environment }}" in
            "Dev") APIM_USERNAME=${{ secrets.APIM_USERNAME_DEV }} ; APIM_PASSWORD=${{ secrets.APIM_PASSWORD_DEV }} ;;
            "SIT") APIM_USERNAME=${{ secrets.APIM_USERNAME_SIT }} ; APIM_PASSWORD=${{ secrets.APIM_PASSWORD_SIT }} ;;
            "SIT-sandbox") APIM_USERNAME=${{ secrets.APIM_USERNAME_SIT_SANDBOX }} ; APIM_PASSWORD=${{ secrets.APIM_PASSWORD_SIT_SANDBOX }} ;;
            "UAT-node-1") APIM_USERNAME=${{ secrets.APIM_USERNAME_UAT_NODE_1 }} ; APIM_PASSWORD=${{ secrets.APIM_PASSWORD_UAT_NODE_1 }} ;;
            "UAT-node-2") APIM_USERNAME=${{ secrets.APIM_USERNAME_UAT_NODE_2 }} ; APIM_PASSWORD=${{ secrets.APIM_PASSWORD_UAT_NODE_2 }} ;;
            "STG-sandbox") APIM_USERNAME=${{ secrets.APIM_USERNAME_STG_SANDBOX }} ; APIM_PASSWORD=${{ secrets.APIM_PASSWORD_STG_SANDBOX }} ;;
          esac

          apictl login "$APIM_ENV" -u "$APIM_USERNAME" -p "$APIM_PASSWORD" -k

  # =====================================
  # 3. Determine API list to export
  # =====================================
  determine-apis:
    runs-on: [self-hosted, linux]
    needs: apim-login
    outputs:
      api-names: ${{ steps.determine.outputs.api_names }}
    steps:
      - uses: actions/checkout@v4

      - id: determine
        run: |
          set -euo pipefail
          APIM_ENV="${{ inputs.environment }}"

          mapfile -t ALL_APIS < <(apictl get apis -e "$APIM_ENV" -k | awk 'NR>1 {print $2}')
          USER_INPUT="${{ inputs.includeAPIs }}"
          VALID_APIS=()

          if [[ -z "$USER_INPUT" ]]; then
            VALID_APIS=("${ALL_APIS[@]}")
          else
            IFS=',' read -ra USER_APIS <<< "$USER_INPUT"
            for api in "${USER_APIS[@]}"; do
              api_trimmed="$(echo "$api" | xargs)"
              if printf '%s\n' "${ALL_APIS[@]}" | grep -Fxq "$api_trimmed"; then
                VALID_APIS+=("$api_trimmed")
              else
                echo "Invalid API: $api_trimmed"
              fi
            done
          fi

          api_csv="$(printf '%s,' "${VALID_APIS[@]}" | sed 's/,$//')"
          echo "api_names=$api_csv" >> $GITHUB_OUTPUT

      - name: Save API list
        run: echo "${{ steps.determine.outputs.api_names }}" > api_list.txt

      - uses: actions/upload-artifact@v4
        with:
          name: api-list
          path: api_list.txt

  # =====================================
  # 4. Export API artifacts
  # =====================================
  export-apis:
    runs-on: [self-hosted, linux]
    needs: determine-apis
    env:
      APIM_ENV: ${{ inputs.environment }}

    steps:
      - uses: actions/checkout@v4

      - uses: actions/download-artifact@v4
        with:
          name: api-list

      - name: Export APIs
        run: |
          mkdir -p dist
          API_NAMES=$(cat api_list.txt)

          IFS=',' read -ra API_ARRAY <<< "$API_NAMES"

          for API_NAME in "${API_ARRAY[@]}"; do
            RECORD="$(apictl get apis -e "$APIM_ENV" -k | awk -v n="$API_NAME" 'NR>1 && $2==n')"
            VERSION="$(awk '{print $3}' <<< "$RECORD")"
            PROVIDER="$(awk '{print $6}' <<< "$RECORD")"

            apictl export api -n "$API_NAME" -v "$VERSION" -r "$PROVIDER" \
              -e "$APIM_ENV" --format YAML -k
          done

      - uses: actions/upload-artifact@v4
        with:
          name: dist
          path: dist

  # =====================================
  # 5. Release packaging & upload
  # =====================================
  release:
    runs-on: [self-hosted, linux]
    needs: export-apis
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    steps:
      - uses: actions/checkout@v4

      - uses: actions/download-artifact@v4
        with:
          name: dist
          path: dist

      - name: Package Release
        run: |
          TAG="${{ inputs.version }}"
          ZIP="${TAG}-release-apis.zip"
          cd dist
          zip -r "../$ZIP" .

      - name: Upload to Release
        run: |
          TAG="${{ inputs.version }}"
          ZIP="${TAG}-release-apis.zip"

          if ! gh release view "$TAG" >/dev/null 2>&1; then
            gh release create "$TAG" --title "$TAG" --notes "Automated release"
          fi

          gh release upload "$TAG" "$ZIP" --clobber


================================================= 27/11


      - name: Notify Deployment Status
        run: |
          set -euo pipefail

          TITLE=""
          COLOR=""
          PASSED_JOBS=""
          FAILED_JOBS=""
          SKIPPED_JOBS=""
          OPTIONAL_FAILED_JOBS=""

          EXPORT_APIS="${{ steps.determine_apis.outputs.api_names }}"

          prettify() {
            sed -E 's/([a-z])([A-Z])/\1 \2/g' <<< "$1"
          }

          pad_right() {
            printf "%-30s" "$1"
          }

          NEEDS_JSON='${{ toJson(needs) }}'
          TOPIC_STATUS="${{ needs.fetch-repo-topics.outputs.topic_status }}"

          echo "Fetching job results..."
          for job in $(jq -r 'keys[]' <<< "$NEEDS_JSON"); do
            RESULT=$(jq -r ".\"$job\".result" <<< "$NEEDS_JSON")
            JOB_NAME=$(prettify "$job")
            PADDED_JOB_NAME=$(pad_right "$JOB_NAME")

            if [[ "$job" == "copyright-check" ]]; then
              COPYRIGHT_FAILED="${{ needs.copyright-check.outputs.copyright_failed }}"
              if [[ "$COPYRIGHT_FAILED" == "true" ]]; then
                if [[ "$TOPIC_STATUS" != "new" ]]; then
                  OPTIONAL_FAILED_JOBS+="- âŒ $PADDED_JOB_NAME\n"
                  continue
                fi
                RESULT="failure"
              fi
            elif [[ "$job" == "code-formatting-check" ]]; then
              FORMATTING_FAILED="${{ needs.code-formatting-check.outputs.formatting_failed }}"
              if [[ "$FORMATTING_FAILED" == "true" ]]; then
                if [[ "$TOPIC_STATUS" != "new" ]]; then
                  OPTIONAL_FAILED_JOBS+="- âŒ $PADDED_JOB_NAME\n"
                  continue
                fi
                RESULT="failure"
              fi
            fi

            if [[ "$RESULT" == "success" ]]; then
              PASSED_JOBS+="- âœ… $PADDED_JOB_NAME\n"
            elif [[ "$RESULT" == "failure" ]]; then
              FAILED_JOBS+="- âŒ $PADDED_JOB_NAME\n"
            else
              SKIPPED_JOBS+="- âš ï¸ $PADDED_JOB_NAME\n"
            fi
          done

          # ---------------------------------------------------------
          #  NEW LOGIC FOR SUCCESS/FAILURE (Requirement #2 and #3)
          # ---------------------------------------------------------
          if [[ -z "$FAILED_JOBS" && -z "$SKIPPED_JOBS" ]]; then
            TITLE="âœ… Pre-Release Verification: Success | Release Ready"
            COLOR="2E8B57"
          else
            TITLE="âŒ Pre-Release Verification: Failed | Release Blocked"
            COLOR="B22222"
          fi
          # ---------------------------------------------------------

          # Build message facts
          FACTS="[ \
            {\"name\":\"ðŸ“‹ Workflow:\", \"value\":\"${{ github.workflow }}\"}, \
            {\"name\":\"ðŸŒ¿ Branch:\", \"value\":\"${{ github.ref_name }}\"}, \
            {\"name\":\"ðŸ”— Commit:\", \"value\":\"${{ github.sha }}\"}, \
            {\"name\":\"ðŸ‘¤ Initiated By:\", \"value\":\"${{ github.actor }}\"}, \
            {\"name\":\"ðŸ“Œ Project Category:\", \"value\":\"$TOPIC_STATUS\"}, \
            {\"name\":\"ðŸ“¦ APIs To Export:\", \"value\":\"${EXPORT_APIS}\"} \
          ]"

          # Build Teams card
          JSON_PAYLOAD=$(cat <<EOF
          {
            "@type": "MessageCard",
            "@context": "https://schema.org/extensions",
            "summary": "$TITLE",
            "themeColor": "$COLOR",
            "title": "$TITLE",
            "sections": [
              {
                "activityTitle": "**Repository: ${{ github.repository }}**",
                "facts": $FACTS
              }
            ]
          }
          EOF
          )

          curl -s -f -H 'Content-Type: application/json' \
            -d "$JSON_PAYLOAD" \
            "${{ env.TEAMS_WEBHOOK_URL_APIM_EXPORT }}"
