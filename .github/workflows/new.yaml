name: Reusable workflow for deploying APIM APIs

on:
  workflow_call:
    inputs:
      includeAPIs:
        description: 'Comma-separated list of APIM APIs to include'
        required: true
        type: string
       
      releaseVersion:
        description: 'The Git release version which use with the enviorenment'
        required: true
        type: string

      triggeredBy:
        description: "Flag to indicate this is from child workflow"
        required: false
        default: "false"
        type: string
       
      environment:
        description: "API Deployment Environment"
        required: false
        default: "Dev"
        type: string
       
jobs:
  prepare-workspace:
    name: Define Workspace
    runs-on: [self-hosted, linux]
    outputs:
      workspace-path: ${{ steps.define_workspace.outputs.workspace }}
    steps:
      - name: Define Workspace
        id: define_workspace
        run: |
          WS="${{ github.workspace }}/${{ github.run_id }}-ci"
          mkdir -p "$WS"
          echo "workspace=$WS" >> $GITHUB_OUTPUT
          echo "Workspace directory created: $WS"
         
  determine_apis:
    name: Determine APIs to process
    runs-on: [self-hosted, linux]
    needs:
      - prepare-workspace
    env:
      WORKSPACE: ${{ needs.prepare-workspace.outputs.workspace-path }}
      APIM_ENV: ${{ inputs.environment }}
    outputs:
      apis-to-deploy: ${{ steps.detect_apis.outputs.zip_files }}
    steps:
      - name: Download GitHub Release ZIP (Auto Asset Detection + Retry)
        working-directory: ${{ env.WORKSPACE }}
        id: download_release
        run: |
          set -e
          pwd
          REPO="sampathbankplc/middleware-apim-sampathvishwa-app-apis"
          INPUT_VER="${{ inputs.releaseVersion }}"
     
          echo "üîç Requested release version: $INPUT_VER"
     
          # Determine release tag
          if [ "$INPUT_VER" = "latest" ]; then
            echo "üì¶ Fetching latest release metadata..."
            RELEASE_JSON=$(curl -s \
              -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/$REPO/releases/latest")
          else
            echo "üì¶ Fetching release metadata for tag $INPUT_VER..."
            RELEASE_JSON=$(curl -s \
              -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/$REPO/releases/tags/$INPUT_VER")
          fi
     
          # Extract release tag
          RELEASE_TAG=$(echo "$RELEASE_JSON" | jq -r '.tag_name')
          echo "‚úÖ Release tag resolved to: $RELEASE_TAG"
     
          # Expected filename pattern
          EXPECTED_FILE="${RELEASE_TAG}-release-apis.zip"
     
          echo "üîç Looking for asset file: $EXPECTED_FILE"
     
          # Extract asset ID from release assets json
          ASSET_ID=$(echo "$RELEASE_JSON" \
            | jq -r ".assets[] | select(.name == \"$EXPECTED_FILE\") | .id")
     
          if [ -z "$ASSET_ID" ] || [ "$ASSET_ID" = "null" ]; then
            echo "‚ùå ERROR: Could not find asset '$EXPECTED_FILE' in release '$RELEASE_TAG'"
            echo "Available assets:"
            echo "$RELEASE_JSON" | jq -r '.assets[].name'
            exit 1
          fi
     
          echo "üìÑ Found asset ID: $ASSET_ID"
     
          ASSET_URL="https://api.github.com/repos/$REPO/releases/assets/$ASSET_ID"
     
          echo "üåê Download URL (GitHub API): $ASSET_URL"
     
          # Retry logic: 3 attempts with delay
          attempt=1
          while [ $attempt -le 3 ]; do
            echo "‚¨áÔ∏è Download attempt $attempt..."
     
            curl -L \
              -H "Accept: application/octet-stream" \
              -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              -o release.zip \
              "$ASSET_URL" && break
     
            echo "‚ö†Ô∏è Download failed (attempt $attempt)"
            attempt=$((attempt + 1))
            sleep 2
          done
     
          if [ ! -f release.zip ]; then
            echo "‚ùå ERROR: Failed to download release asset after 3 attempts"
            exit 1
          fi
     
          echo "üìÅ Download completed. File info:"
          ls -lh release.zip
          file release.zip
     
          # Validate ZIP
          if ! file release.zip | grep -q "Zip archive data"; then
            echo "‚ùå ERROR: Downloaded file is NOT a zip archive"
            echo "It may be an HTML output from GitHub"
            cat release.zip | head -20 || true
            exit 1
          fi
     
          echo "üìÇ Extracting ZIP..."
          unzip -q release.zip -d release_content
     
          echo "‚úÖ Extraction finished."
           
      - name: Determine APIs to deploy
        working-directory: ${{ env.WORKSPACE }}
        id: detect_apis
        run: |
          set -e
     
          INPUT="${{ inputs.includeAPIs }}"
          TRIGGERED_BY="${{ inputs.triggeredBy }}"
          ENV_PATH="apis/${{ env.APIM_ENV }}"
          API_ROOT="release_content/${ENV_PATH}"
     
          if [ ! -d "$API_ROOT" ]; then
            echo "‚ùå ERROR: Directory '$API_ROOT' not found in release!"
            exit 1
          fi
     
          echo "üìÅ Looking for API ZIPs inside: $API_ROOT"
     
          to_zip() {
            local api="$1"
            if [[ "$api" == *.zip ]]; then
              echo "$api"
            else
              echo "${api}.zip"
            fi
          }
     
          if [ -z "$INPUT" ] && [ "$TRIGGERED_BY" == "developer" ]; then
            echo "‚ùå Developer trigger but no includeAPIs input ‚Äî stopping pipeline"
            exit 1
     
          elif [ -z "$INPUT" ] && [ "$TRIGGERED_BY" == "apim-team" ]; then
            echo "‚öôÔ∏è APIM team trigger ‚Äî including ALL ZIPs from the release"
     
            FILES=("$API_ROOT"/*.zip)
     
            if [ ! -e "${FILES[0]}" ]; then
              echo "‚ùå No ZIP files found in '$API_ROOT'"
              exit 1
            fi
     
            ZIP_FILES=$(printf "%s\n" "${FILES[@]##*/}")  # Extract basenames, newline-separated
     
          else
            echo "User input APIs: $INPUT"
            IFS=',' read -r -a ARR <<< "$INPUT"
     
            VALID_ZIPS=()
            INVALID_ZIPS=()
     
            for api in "${ARR[@]}"; do
              api=$(echo "$api" | xargs)  # trim spaces
              zip_file=$(to_zip "$api")
     
              if [ -f "$API_ROOT/$zip_file" ]; then
                VALID_ZIPS+=("$zip_file")
              else
                INVALID_ZIPS+=("$zip_file")
              fi
            done
     
            if [ ${#INVALID_ZIPS[@]} -ne 0 ]; then
              echo "‚ö†Ô∏è WARNING: These ZIP files do NOT exist in the release: ${INVALID_ZIPS[*]}"
            fi
     
            if [ ${#VALID_ZIPS[@]} -eq 0 ]; then
              echo "‚ùå No valid APIs found in release for input!"
              exit 1
            fi
     
            ZIP_FILES=$(printf "%s\n" "${VALID_ZIPS[@]}")  # newline-separated
          fi
     
          echo "‚úÖ Final ZIP files to deploy:"
          echo "$ZIP_FILES"
     
          # Export as workflow output
          {
            echo "zip_files<<EOF"
            echo "$ZIP_FILES"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"


  validate-api-artifacts:
    name: Validate API Preconditions
    runs-on: [self-hosted, linux]
    needs:
      - determine_apis
      - prepare-workspace
    env:
      DEPLOY_APIS: ${{ needs.determine_apis.outputs.apis-to-deploy }}
      APIM_ENV: ${{ inputs.environment }}
      WORKSPACE: ${{ needs.prepare-workspace.outputs.workspace-path }}
    steps:          
      - name: Install apictl
        working-directory: ${{ env.WORKSPACE }}
        run: |
          echo $RUNNER_WORKSPACE
          WORK_DIR="$RUNNER_WORKSPACE/apictl-4.1.6"
          mkdir -p "$WORK_DIR"
 
          if [ ! -f "$WORK_DIR/apictl/apictl" ]; then
            cd "$WORK_DIR"
            echo "Downloading apictl to $WORK_DIR..."
            wget "https://github.com/wso2/product-apim-tooling/releases/download/v4.1.6/apictl-4.1.6-linux-amd64.tar.gz"
            tar -xvzf apictl-4.1.6-linux-amd64.tar.gz
          fi
          chmod +x "$WORK_DIR/apictl/apictl"
 
          echo "$WORK_DIR/apictl" >> $GITHUB_PATH
          echo "apictl path added to PATH: $WORK_DIR"

      - name: Verify apictl version
        run: apictl version

      - name: Extract & Validate API Categories in WSO2 APIM
        id: extract_categories
        working-directory: ${{ env.WORKSPACE }}
        shell: bash
        env:
          TOKEN: ${{ secrets.APIM_ADMIN_TOKEN }}
        run: |
          # Map APIM_ENV to corresponding secret
          case "${{ env.APIM_ENV }}" in
            Dev)
              APIM_HOST="${{ secrets.APIM_ENV_URL_DEV }}"
              ;;
            SIT)
              APIM_HOST="${{ secrets.APIM_ENV_URL_SIT }}"
              ;;
            SIT-sandbox)
              APIM_HOST="${{ secrets.APIM_ENV_URL_SIT-sandbox }}"
              ;;
            UAT-node-1)
              APIM_HOST="${{ secrets.APIM_ENV_URL_UAT-node-1 }}"
              ;;
            UAT-node-2)
              APIM_HOST="${{ secrets.APIM_ENV_URL_UAT-node-2 }}"
              ;;
            STG-sandbox)
              APIM_HOST="${{ secrets.APIM_ENV_URL_STG-sandbox }}"
              ;;
            *)
              echo "‚ùå Unknown APIM_ENV: ${{ env.APIM_ENV }}"
              exit 1
              ;;
          esac

          echo "Using APIM_HOST: $APIM_HOST for environment ${{ env.APIM_ENV }}"

          API_PATH="release_content/apis/${{ env.APIM_ENV }}"
          echo "üìÇ Scanning APIs in: $API_PATH"
          echo ""

          # Endpoint for API Category Administration
          CATEGORY_API="https://${APIM_HOST}/api/am/admin/v1/api-categories"

          # A set to avoid duplicate creations
          declare -A FOUND_CATEGORIES

          for ZIP in "$API_PATH"/*.zip; do
            echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
            echo "üîç Processing: $ZIP"

            FOLDER="${ZIP%.zip}"
            mkdir -p "$FOLDER"
            unzip -q "$ZIP" -d "$FOLDER"

            API_YAML=$(find "$FOLDER" -type f -name "api.yaml" | head -1)

            if [ -z "$API_YAML" ]; then
              echo "‚ùå api.yaml NOT FOUND inside $ZIP"
              continue
            fi

            echo "‚úî Found api.yaml at: $API_YAML"

            # Extract all categories listed under "categories:"
            CATEGORIES=$(yq eval '.categories[]' "$API_YAML" 2>/dev/null)

            if [ -z "$CATEGORIES" ]; then
              echo "‚ö†Ô∏è No categories defined for this API"
              echo ""
              continue
            fi

            echo "üìå Categories found:"
            echo "$CATEGORIES"
            echo ""

            # Validate each category
            for CATEGORY in $CATEGORIES; do

              # Avoid processing same category twice
              if [[ ${FOUND_CATEGORIES[$CATEGORY]} == 1 ]]; then
                echo "‚û° Category '$CATEGORY' already validated earlier. Skipping."
                continue
              fi

              echo "üîé Checking if category '$CATEGORY' exists in WSO2 APIM..."

              # Check via GET
              EXISTS=$(curl -s -k -H "Authorization: Bearer $TOKEN" \
                          "$CATEGORY_API?limit=1000" | yq eval ".list[] | select(.name == \"$CATEGORY\") | .name" -)

              if [[ "$EXISTS" == "$CATEGORY" ]]; then
                echo "‚úî Category '$CATEGORY' already exists in APIM."
                FOUND_CATEGORIES[$CATEGORY]=1
              else
                echo "‚ö†Ô∏è Category '$CATEGORY' NOT FOUND!"
                echo "üü¢ Creating API category '$CATEGORY'..."

                CREATE_PAYLOAD=$(jq -n --arg name "$CATEGORY" \
                  '{name: $name, description: "Auto-created via CI/CD pipeline"}')

                CREATE_RESPONSE=$(curl -s -k -X POST "$CATEGORY_API" \
                  -H "Authorization: Bearer $TOKEN" \
                  -H "Content-Type: application/json" \
                  -d "$CREATE_PAYLOAD")

                if echo "$CREATE_RESPONSE" | grep -q '"id"'; then
                  echo "üéâ Category '$CATEGORY' created successfully!"
                  FOUND_CATEGORIES[$CATEGORY]=1
                else
                  echo "‚ùå Failed to create category '$CATEGORY'. API response:"
                  echo "$CREATE_RESPONSE"
                  exit 1
                fi
              fi

              echo ""
            done

          done

          echo "‚úÖ Completed API category validation & creation process."
  
  pre-deploy-notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs:
      - determine_apis
      - validate-api-artifacts
    if: always()
    env:
      TEAMS_WEBHOOK_URL: ${{ secrets.TEAMS_WEBHOOK_URL_APIM_IMPORT }}
      DEPLOY_APIS: ${{ needs.determine_apis.outputs.apis-to-deploy }}
      RELEASE_VERSION: ${{ inputs.releaseVersion }}
     
    steps:
      - name: Notify Deployment Status
        run: |
 
          echo "${{ env.DEPLOY_APIS }}"
 
          set -euo pipefail
          TITLE=""
          COLOR=""
          PASSED_JOBS=""
          FAILED_JOBS=""
          SKIPPED_JOBS=""
          OPTIONAL_FAILED_JOBS=""
 
          prettify() {
            echo "$1" | sed -E 's/([a-z])([A-Z])/\1 \2/g'
          }
 
          pad_right() {
            printf "%-30s" "$1"
          }
 
          NEEDS_JSON='${{ toJson(needs) }}'
 
          echo "Fetching job results..."
          for job in $(jq -r 'keys[]' <<< "$NEEDS_JSON"); do
            RESULT=$(jq -r ".\"$job\".result" <<< "$NEEDS_JSON")
            JOB_NAME=$(prettify "$job")
            PADDED_JOB_NAME=$(pad_right "$JOB_NAME")
 
            if [[ "$RESULT" == "success" ]]; then
              PASSED_JOBS+="- ‚úÖ $PADDED_JOB_NAME\n"
            elif [[ "$RESULT" == "failure" ]]; then
              FAILED_JOBS+="- ‚ùå $PADDED_JOB_NAME\n"
            else
              SKIPPED_JOBS+="- ‚ö†Ô∏è $PADDED_JOB_NAME\n"
            fi
          done
 
          if [[ -z "$FAILED_JOBS" && -z "$SKIPPED_JOBS" ]]; then
            TITLE="‚úÖ Pre-Deployment Verification: Success | Deployment Ready"
            COLOR="2E8B57"
          else
            TITLE="‚ùå Pre-Deployment Verification: Failed | Deployment Blocked"
            COLOR="B22222"
          fi
 
          FACTS="[ \
            {\"name\":\"üìã Workflow:\", \"value\":\"${{ github.workflow }}\"}, \
            {\"name\":\"üåø Branch:\", \"value\":\"${{ github.ref_name }}\"}, \
            {\"name\":\"üîó Commit:\", \"value\":\"${{ github.sha }}\"}, \
            {\"name\":\"üë§ Initiated By:\", \"value\":\"${{ github.actor }}\"}, \
            {\"name\":\"üè∑Ô∏è Release Version:\", \"value\":\"${{ env.RELEASE_VERSION }}\"}, \
            {\"name\":\"üìÇ APIs to Deploy:\", \"value\":\"\"}, \
            {\"name\":\"\", \"value\":\"$(echo -e "${{ env.DEPLOY_APIS }}" | sed 's/"/\\"/g')\"} \
          "
 
          [[ -n "$PASSED_JOBS" ]] && FACTS+=", {\"name\":\"‚úÖ Passed Jobs\", \"value\":\"\"}, {\"name\":\"\", \"value\":\"$(echo -e "$PASSED_JOBS" | sed 's/"/\\"/g')\"}"
          [[ -n "$FAILED_JOBS" ]] && FACTS+=", {\"name\":\"‚ùå Failed Jobs\", \"value\":\"\"}, {\"name\":\"\", \"value\":\"$(echo -e "$FAILED_JOBS" | sed 's/"/\\"/g')\"}"
          [[ -n "$SKIPPED_JOBS" ]] && FACTS+=", {\"name\":\"‚ö†Ô∏è Skipped Jobs\", \"value\":\"\"}, {\"name\":\"\", \"value\":\"$(echo -e "$SKIPPED_JOBS" | sed 's/"/\\"/g')\"}"
          [[ -n "$OPTIONAL_FAILED_JOBS" ]] && FACTS+=", {\"name\":\"‚ùå Failed (Optional)\", \"value\":\"\"}, {\"name\":\"\", \"value\":\"$(echo -e "$OPTIONAL_FAILED_JOBS" | sed 's/"/\\"/g')\"}"
 
          FACTS+="]"
 
          JSON_PAYLOAD=$(cat <<EOF
          {
            "@type": "MessageCard",
            "@context": "https://schema.org/extensions",
            "summary": "$TITLE",
            "themeColor": "$COLOR",
            "title": "$TITLE",
            "sections": [
              {
                "activityTitle": "**Repository: ${{ github.repository }}**",
                "facts": $FACTS
              }
            ]
          }
          EOF
          )
 
          curl -s -f -H 'Content-Type: application/json' \
            -d "$JSON_PAYLOAD" \
            "${{ env.TEAMS_WEBHOOK_URL }}"

  deploy-apis-to-apim:
    name: Deploy APIM API
    # environment: dev-integration
    runs-on: [self-hosted, linux]
    needs:
      - prepare-workspace
      - determine_apis
      - pre-deploy-notify
    env:
      WORKSPACE: ${{ needs.prepare-workspace.outputs.workspace-path }}
      DEPLOY_APIS: ${{ needs.determine_apis.outputs.apis-to-deploy }}
      APIM_ENV: ${{ inputs.environment }}
    strategy:
      max-parallel: 1
    steps:
      - name: Install apictl
        working-directory: ${{ env.WORKSPACE }}
        run: |
          pwd
          echo $RUNNER_WORKSPACE
          WORK_DIR="$RUNNER_WORKSPACE/apictl-4.1.6"
          mkdir -p "$WORK_DIR"
 
          if [ ! -f "$WORK_DIR/apictl/apictl" ]; then
            cd "$WORK_DIR"
            echo "Downloading apictl to $WORK_DIR..."
            wget "https://github.com/wso2/product-apim-tooling/releases/download/v4.1.6/apictl-4.1.6-linux-amd64.tar.gz"
            tar -xvzf apictl-4.1.6-linux-amd64.tar.gz
          fi
          chmod +x "$WORK_DIR/apictl/apictl"
 
          echo "$WORK_DIR/apictl" >> $GITHUB_PATH
          echo "apictl path added to PATH: $WORK_DIR"

      - name: Verify apictl version
        run: apictl version

      - name: Add Environment
        shell: bash
        run: |
          case "${{ github.event.inputs.environment }}" in
            "Dev")
              APIM_ENV_URL=${{ secrets.APIM_ENV_URL_DEV }}
              ;;
            "SIT")
              APIM_ENV_URL=${{ secrets.APIM_ENV_URL_SIT }}
              ;;
            "SIT-sandbox")
              APIM_ENV_URL=${{ secrets.APIM_ENV_URL_SIT_SANDBOX }}
              ;;
            "UAT-node-1")
               APIM_ENV_URL=${{ secrets.APIM_ENV_URL_UAT_NODE_1 }}
               ;;
            "UAT-node-2")
              APIM_ENV_URL=${{ secrets.APIM_ENV_URL_UAT_NODE_2 }}
              ;;
            "STG-sandbox")
              APIM_ENV_URL=${{ secrets.APIM_ENV_URL_STG_SANDBOX }}
              ;;
            *)
              echo "‚ùå Unknown environment"
              exit 1
              ;;
          esac

          if apictl get envs | grep -q "${{ env.APIM_ENV }}"; then
            echo "Environment '${{ env.APIM_ENV }}' already exists. Skipping."
          else
            apictl add env ${{ env.APIM_ENV }} --apim https://$APIM_ENV_URL
          fi
       
      - name: Deploy API Artifacts
        id: prepareApiForDeployment
        working-directory: ${{ env.WORKSPACE }}
        run: |
          set -euo pipefail
     
          # Increase apictl timeout
          apictl set --http-request-timeout 300000
     
          # Set credentials based on environment
          case "${{ github.event.inputs.environment }}" in
            "Dev")
              APIM_USERNAME=${{ secrets.APIM_USERNAME_DEV }}
              APIM_PASSWORD=${{ secrets.APIM_PASSWORD_DEV }}
              ;;
            "SIT")
              APIM_USERNAME=${{ secrets.APIM_USERNAME_SIT }}
              APIM_PASSWORD=${{ secrets.APIM_PASSWORD_SIT }}
              ;;
            "SIT-sandbox")
              APIM_USERNAME=${{ secrets.APIM_USERNAME_SIT_SANDBOX }}
              APIM_PASSWORD=${{ secrets.APIM_PASSWORD_SIT_SANDBOX }}
              ;;
            "UAT-node-1")
              APIM_USERNAME=${{ secrets.APIM_USERNAME_UAT_NODE_1 }}
              APIM_PASSWORD=${{ secrets.APIM_PASSWORD_UAT_NODE_1 }}
              ;;
            "UAT-node-2")
              APIM_USERNAME=${{ secrets.APIM_USERNAME_UAT_NODE_2 }}
              APIM_PASSWORD=${{ secrets.APIM_PASSWORD_UAT_NODE_2 }}
              ;;
            "STG-sandbox")
              APIM_USERNAME=${{ secrets.APIM_USERNAME_STG_SANDBOX }}
              APIM_PASSWORD=${{ secrets.APIM_PASSWORD_STG_SANDBOX }}
              ;;
            *)
              echo "‚ùå Unknown environment"
              exit 1
              ;;
          esac
     
          # Login to APIM
          apictl login "${{ env.APIM_ENV }}" -u "$APIM_USERNAME" -p "$APIM_PASSWORD" -k --verbose
     
          echo "üìÅ APIs to deploy:"
          echo "${{ env.DEPLOY_APIS }}"
     
          # Split DEPLOY_APIS by newline
          IFS=$'\n'
          for api in $DEPLOY_APIS; do
            api=$(echo "$api" | xargs)  # trim spaces
            echo "üöÄ Deploying API: $api"
     
            if apictl import api \
              -f "${{ env.WORKSPACE }}/release_content/apis/${{ env.APIM_ENV }}/$api" \
              -e "${{ env.APIM_ENV }}" \
              -k \
              --rotate-revision \
              --verbose; then
                echo "‚úÖ Imported $api successfully"
            else
                echo "‚ùå Failed to import $api"
                echo "üîç Error details logged above"
                # Continue to next API
            fi
     
            sleep 5
          done
