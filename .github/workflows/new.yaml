name: Reusable workflow for deploying APIM APIs

on:
  workflow_call:
    inputs:
      includeAPIs:
        description: 'Comma-separated list of APIM APIs to include'
        required: true
        type: string
       
      releaseVersion:
        description: 'The Git release version which use with the enviorenment'
        required: true
        type: string

      triggeredBy:
        description: "Flag to indicate this is from child workflow"
        required: false
        default: "false"
        type: string
       
      environment:
        description: "API Deployment Environment"
        required: false
        default: "Dev"
        type: string
       
jobs:
  prepare-workspace:
    name: Define Workspace
    runs-on: [self-hosted, linux]
    outputs:
      workspace-path: ${{ steps.define_workspace.outputs.workspace }}
    steps:
      - name: Define Workspace
        id: define_workspace
        run: |
          WS="${{ github.workspace }}/${{ github.run_id }}-ci"
          mkdir -p "$WS"
          echo "workspace=$WS" >> $GITHUB_OUTPUT
          echo "Workspace directory created: $WS"
         
  determine_apis:
    name: Determine APIs to process
    runs-on: [self-hosted, linux]
    needs:
      - prepare-workspace
    env:
      WORKSPACE: ${{ needs.prepare-workspace.outputs.workspace-path }}
      APIM_ENV: ${{ inputs.environment }}
    outputs:
      apis-to-deploy: ${{ steps.detect_apis.outputs.zip_files }}
    steps:
      - name: Download GitHub Release ZIP (Auto Asset Detection + Retry)
        working-directory: ${{ env.WORKSPACE }}
        id: download_release
        run: |
          set -e
          pwd
          REPO="sampathbankplc/middleware-apim-sampathvishwa-app-apis"
          INPUT_VER="${{ inputs.releaseVersion }}"
     
          echo "üîç Requested release version: $INPUT_VER"
     
          # Determine release tag
          if [ "$INPUT_VER" = "latest" ]; then
            echo "üì¶ Fetching latest release metadata..."
            RELEASE_JSON=$(curl -s \
              -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/$REPO/releases/latest")
          else
            echo "üì¶ Fetching release metadata for tag $INPUT_VER..."
            RELEASE_JSON=$(curl -s \
              -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              "https://api.github.com/repos/$REPO/releases/tags/$INPUT_VER")
          fi
     
          # Extract release tag
          RELEASE_TAG=$(echo "$RELEASE_JSON" | jq -r '.tag_name')
          echo "‚úÖ Release tag resolved to: $RELEASE_TAG"
     
          # Expected filename pattern
          EXPECTED_FILE="${RELEASE_TAG}-release-apis.zip"
     
          echo "üîç Looking for asset file: $EXPECTED_FILE"
     
          # Extract asset ID from release assets json
          ASSET_ID=$(echo "$RELEASE_JSON" \
            | jq -r ".assets[] | select(.name == \"$EXPECTED_FILE\") | .id")
     
          if [ -z "$ASSET_ID" ] || [ "$ASSET_ID" = "null" ]; then
            echo "‚ùå ERROR: Could not find asset '$EXPECTED_FILE' in release '$RELEASE_TAG'"
            echo "Available assets:"
            echo "$RELEASE_JSON" | jq -r '.assets[].name'
            exit 1
          fi
     
          echo "üìÑ Found asset ID: $ASSET_ID"
     
          ASSET_URL="https://api.github.com/repos/$REPO/releases/assets/$ASSET_ID"
     
          echo "üåê Download URL (GitHub API): $ASSET_URL"
     
          # Retry logic: 3 attempts with delay
          attempt=1
          while [ $attempt -le 3 ]; do
            echo "‚¨áÔ∏è Download attempt $attempt..."
     
            curl -L \
              -H "Accept: application/octet-stream" \
              -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
              -o release.zip \
              "$ASSET_URL" && break
     
            echo "‚ö†Ô∏è Download failed (attempt $attempt)"
            attempt=$((attempt + 1))
            sleep 2
          done
     
          if [ ! -f release.zip ]; then
            echo "‚ùå ERROR: Failed to download release asset after 3 attempts"
            exit 1
          fi
     
          echo "üìÅ Download completed. File info:"
          ls -lh release.zip
          file release.zip
     
          # Validate ZIP
          if ! file release.zip | grep -q "Zip archive data"; then
            echo "‚ùå ERROR: Downloaded file is NOT a zip archive"
            echo "It may be an HTML output from GitHub"
            cat release.zip | head -20 || true
            exit 1
          fi
     
          echo "üìÇ Extracting ZIP..."
          unzip -q release.zip -d release_content
     
          echo "‚úÖ Extraction finished."
           
      - name: Determine APIs to deploy
        working-directory: ${{ env.WORKSPACE }}
        id: detect_apis
        run: |
          set -e
     
          INPUT="${{ inputs.includeAPIs }}"
          TRIGGERED_BY="${{ inputs.triggeredBy }}"
          ENV_PATH="apis/${{ env.APIM_ENV }}"
          API_ROOT="release_content/${ENV_PATH}"
     
          if [ ! -d "$API_ROOT" ]; then
            echo "‚ùå ERROR: Directory '$API_ROOT' not found in release!"
            exit 1
          fi
     
          echo "üìÅ Looking for API ZIPs inside: $API_ROOT"
     
          to_zip() {
            local api="$1"
            if [[ "$api" == *.zip ]]; then
              echo "$api"
            else
              echo "${api}.zip"
            fi
          }
     
          if [ -z "$INPUT" ] && [ "$TRIGGERED_BY" == "developer" ]; then
            echo "‚ùå Developer trigger but no includeAPIs input ‚Äî stopping pipeline"
            exit 1
     
          elif [ -z "$INPUT" ] && [ "$TRIGGERED_BY" == "apim-team" ]; then
            echo "‚öôÔ∏è APIM team trigger ‚Äî including ALL ZIPs from the release"
     
            FILES=("$API_ROOT"/*.zip)
     
            if [ ! -e "${FILES[0]}" ]; then
              echo "‚ùå No ZIP files found in '$API_ROOT'"
              exit 1
            fi
     
            ZIP_FILES=$(printf "%s\n" "${FILES[@]##*/}")  # Extract basenames, newline-separated
     
          else
            echo "User input APIs: $INPUT"
            IFS=',' read -r -a ARR <<< "$INPUT"
     
            VALID_ZIPS=()
            INVALID_ZIPS=()
     
            for api in "${ARR[@]}"; do
              api=$(echo "$api" | xargs)  # trim spaces
              zip_file=$(to_zip "$api")
     
              if [ -f "$API_ROOT/$zip_file" ]; then
                VALID_ZIPS+=("$zip_file")
              else
                INVALID_ZIPS+=("$zip_file")
              fi
            done
     
            if [ ${#INVALID_ZIPS[@]} -ne 0 ]; then
              echo "‚ö†Ô∏è WARNING: These ZIP files do NOT exist in the release: ${INVALID_ZIPS[*]}"
            fi
     
            if [ ${#VALID_ZIPS[@]} -eq 0 ]; then
              echo "‚ùå No valid APIs found in release for input!"
              exit 1
            fi
     
            ZIP_FILES=$(printf "%s\n" "${VALID_ZIPS[@]}")  # newline-separated
          fi
     
          echo "‚úÖ Final ZIP files to deploy:"
          echo "$ZIP_FILES"
     
          # Export as workflow output
          {
            echo "zip_files<<EOF"
            echo "$ZIP_FILES"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"


  validate-api-artifacts:
    name: Validate API Preconditions
    runs-on: [self-hosted, linux]
    needs:
      - determine_apis
      - prepare-workspace
    env:
      DEPLOY_APIS: ${{ needs.determine_apis.outputs.apis-to-deploy }}
      APIM_ENV: ${{ inputs.environment }}
      WORKSPACE: ${{ needs.prepare-workspace.outputs.workspace-path }}
    steps:          
      - name: Install apictl
        working-directory: ${{ env.WORKSPACE }}
        run: |
          echo $RUNNER_WORKSPACE
          WORK_DIR="$RUNNER_WORKSPACE/apictl-4.1.6"
          mkdir -p "$WORK_DIR"
 
          if [ ! -f "$WORK_DIR/apictl/apictl" ]; then
            cd "$WORK_DIR"
            echo "Downloading apictl to $WORK_DIR..."
            wget "https://github.com/wso2/product-apim-tooling/releases/download/v4.1.6/apictl-4.1.6-linux-amd64.tar.gz"
            tar -xvzf apictl-4.1.6-linux-amd64.tar.gz
          fi
          chmod +x "$WORK_DIR/apictl/apictl"
 
          echo "$WORK_DIR/apictl" >> $GITHUB_PATH
          echo "apictl path added to PATH: $WORK_DIR"

      - name: Verify apictl version
        run: apictl version

      - name: Install yq
        working-directory: ${{ env.WORKSPACE }}
        run: |
          echo "Installing yq locally..."
          YQ_DIR="$RUNNER_WORKSPACE/yq"
          mkdir -p "$YQ_DIR"
      
          if [ ! -f "$YQ_DIR/yq" ]; then
            wget -O "$YQ_DIR/yq" https://github.com/mikefarah/yq/releases/download/v4.43.2/yq_linux_amd64
            chmod +x "$YQ_DIR/yq"
          fi
      
          # Add local yq to PATH for subsequent steps
          echo "$YQ_DIR" >> $GITHUB_PATH
          echo "yq path added: $YQ_DIR"
          echo "yq version: $($YQ_DIR/yq --version)"

      - name: Extract & Validate API Categories in WSO2 APIM
        id: extract_categories
        working-directory: ${{ env.WORKSPACE }}
        shell: bash
        run: |
          # Map APIM_ENV to corresponding secrets
          case "${{ env.APIM_ENV }}" in
            Dev)
              APIM_HOST="${{ secrets.APIM_ENV_URL_DEV }}"
              APIM_USERNAME="${{ secrets.APIM_USERNAME_DEV }}"
              APIM_PASSWORD="${{ secrets.APIM_PASSWORD_DEV }}"
              ;;
            SIT)
              APIM_HOST="${{ secrets.APIM_ENV_URL_SIT }}"
              APIM_USERNAME="${{ secrets.APIM_USERNAME_SIT }}"
              APIM_PASSWORD="${{ secrets.APIM_PASSWORD_SIT }}"
              ;;
            SIT-sandbox)
              APIM_HOST="${{ secrets.APIM_ENV_URL_SIT_SANDBOX }}"
              APIM_USERNAME="${{ secrets.APIM_USERNAME_SIT_SANDBOX }}"
              APIM_PASSWORD="${{ secrets.APIM_PASSWORD_SIT_SANDBOX }}"
              ;;
            UAT-node-1)
              APIM_HOST="${{ secrets.APIM_ENV_URL_UAT_NODE_1 }}"
              APIM_USERNAME="${{ secrets.APIM_USERNAME_UAT_NODE_1 }}"
              APIM_PASSWORD="${{ secrets.APIM_PASSWORD_UAT_NODE_1 }}"
              ;;
            UAT-node-2)
              APIM_HOST="${{ secrets.APIM_ENV_URL_UAT_NODE_2 }}"
              APIM_USERNAME="${{ secrets.APIM_USERNAME_UAT_NODE_2 }}"
              APIM_PASSWORD="${{ secrets.APIM_PASSWORD_UAT_NODE_2 }}"
              ;;
            STG-sandbox)
              APIM_HOST="${{ secrets.APIM_ENV_URL_STG_SANDBOX }}"
              APIM_USERNAME="${{ secrets.APIM_USERNAME_STG_SANDBOX }}"
              APIM_PASSWORD="${{ secrets.APIM_PASSWORD_STG_SANDBOX }}"
              ;;
            *)
              echo "‚ùå Unknown APIM_ENV: ${{ env.APIM_ENV }}"
              exit 1
              ;;
          esac
      
          # Encode username:password in base64 for basic auth
          AUTH_HEADER=$(echo -n "$APIM_USERNAME:$APIM_PASSWORD" | base64)
      
          API_PATH="release_content/apis/${{ env.APIM_ENV }}"
          echo "üìÇ Scanning APIs in: $API_PATH"
          echo ""
      
          # A set to avoid duplicate category processing
          declare -A FOUND_CATEGORIES
      
          for ZIP in "$API_PATH"/*.zip; do
            echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
            echo "üîç Processing: $ZIP"
      
            FOLDER="${ZIP%.zip}"
            mkdir -p "$FOLDER"
            unzip -q "$ZIP" -d "$FOLDER"
      
            API_YAML=$(find "$FOLDER" -type f -name "api.yaml" | head -1)
      
            if [ -z "$API_YAML" ]; then
              echo "‚ùå api.yaml NOT FOUND inside $ZIP"
              continue
            fi
      
            echo "‚úî Found api.yaml at: $API_YAML"
      
            CATEGORIES=$(yq eval '.categories[]' "$API_YAML" 2>/dev/null)
      
            if [ -z "$CATEGORIES" ]; then
              echo "‚ö†Ô∏è No categories defined for this API"
              echo ""
              continue
            fi
      
            echo "üìå Categories found:"
            echo "$CATEGORIES"
            echo ""
      
            for CATEGORY in $CATEGORIES; do
              if [[ ${FOUND_CATEGORIES[$CATEGORY]} == 1 ]]; then
                echo "‚û° Category '$CATEGORY' already validated earlier. Skipping."
                continue
              fi
      
              echo "üîé Checking if category '$CATEGORY' exists in WSO2 APIM..."
              
              EXISTS=$(curl -s -X GET "$APIM_HOST/api/am/admin/api-categories" \
                        -H "accept: application/json" \
                        -H "Authorization: Basic $AUTH_HEADER" \
                        | jq -r ".list[] | select(.name==\"$CATEGORY\") | .name")
      
              if [[ "$EXISTS" == "$CATEGORY" ]]; then
                echo "‚úî Category '$CATEGORY' already exists in APIM."
                FOUND_CATEGORIES[$CATEGORY]=1
              else
                echo "‚ö†Ô∏è Category '$CATEGORY' NOT FOUND! Creating..."
                
                CREATE_RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" -X POST "$APIM_HOST/api/am/admin/api-categories" \
                                    -H "accept: application/json" \
                                    -H "Content-Type: application/json" \
                                    -H "Authorization: Basic $AUTH_HEADER" \
                                    -d "{\"name\": \"$CATEGORY\", \"description\": \"Created by CI/CD\"}")
      
                if [[ "$CREATE_RESPONSE" == "201" ]]; then
                  echo "üéâ Category '$CATEGORY' created successfully!"
                  FOUND_CATEGORIES[$CATEGORY]=1
                else
                  echo "‚ùå Failed to create category '$CATEGORY' (HTTP code: $CREATE_RESPONSE)"
                  exit 1
                fi
              fi
      
              echo ""
            done
      
          done
      
          echo "‚úÖ Completed API category validation & creation process."

        
  pre-deploy-notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs:
      - determine_apis
      - validate-api-artifacts
    if: always()
    env:
      TEAMS_WEBHOOK_URL: ${{ secrets.TEAMS_WEBHOOK_URL_APIM_IMPORT }}
      DEPLOY_APIS: ${{ needs.determine_apis.outputs.apis-to-deploy }}
      RELEASE_VERSION: ${{ inputs.releaseVersion }}
     
    steps:
      - name: Notify Deployment Status
        run: |
 
          echo "${{ env.DEPLOY_APIS }}"
 
          set -euo pipefail
          TITLE=""
          COLOR=""
          PASSED_JOBS=""
          FAILED_JOBS=""
          SKIPPED_JOBS=""
          OPTIONAL_FAILED_JOBS=""
 
          prettify() {
            echo "$1" | sed -E 's/([a-z])([A-Z])/\1 \2/g'
          }
 
          pad_right() {
            printf "%-30s" "$1"
          }
 
          NEEDS_JSON='${{ toJson(needs) }}'
 
          echo "Fetching job results..."
          for job in $(jq -r 'keys[]' <<< "$NEEDS_JSON"); do
            RESULT=$(jq -r ".\"$job\".result" <<< "$NEEDS_JSON")
            JOB_NAME=$(prettify "$job")
            PADDED_JOB_NAME=$(pad_right "$JOB_NAME")
 
            if [[ "$RESULT" == "success" ]]; then
              PASSED_JOBS+="- ‚úÖ $PADDED_JOB_NAME\n"
            elif [[ "$RESULT" == "failure" ]]; then
              FAILED_JOBS+="- ‚ùå $PADDED_JOB_NAME\n"
            else
              SKIPPED_JOBS+="- ‚ö†Ô∏è $PADDED_JOB_NAME\n"
            fi
          done
 
          if [[ -z "$FAILED_JOBS" && -z "$SKIPPED_JOBS" ]]; then
            TITLE="‚úÖ Pre-Deployment Verification: Success | Deployment Ready"
            COLOR="2E8B57"
          else
            TITLE="‚ùå Pre-Deployment Verification: Failed | Deployment Blocked"
            COLOR="B22222"
          fi
 
          FACTS="[ \
            {\"name\":\"üìã Workflow:\", \"value\":\"${{ github.workflow }}\"}, \
            {\"name\":\"üåø Branch:\", \"value\":\"${{ github.ref_name }}\"}, \
            {\"name\":\"üîó Commit:\", \"value\":\"${{ github.sha }}\"}, \
            {\"name\":\"üë§ Initiated By:\", \"value\":\"${{ github.actor }}\"}, \
            {\"name\":\"üè∑Ô∏è Release Version:\", \"value\":\"${{ env.RELEASE_VERSION }}\"}, \
            {\"name\":\"üìÇ APIs to Deploy:\", \"value\":\"\"}, \
            {\"name\":\"\", \"value\":\"$(echo -e "${{ env.DEPLOY_APIS }}" | sed 's/"/\\"/g')\"} \
          "
 
          [[ -n "$PASSED_JOBS" ]] && FACTS+=", {\"name\":\"‚úÖ Passed Jobs\", \"value\":\"\"}, {\"name\":\"\", \"value\":\"$(echo -e "$PASSED_JOBS" | sed 's/"/\\"/g')\"}"
          [[ -n "$FAILED_JOBS" ]] && FACTS+=", {\"name\":\"‚ùå Failed Jobs\", \"value\":\"\"}, {\"name\":\"\", \"value\":\"$(echo -e "$FAILED_JOBS" | sed 's/"/\\"/g')\"}"
          [[ -n "$SKIPPED_JOBS" ]] && FACTS+=", {\"name\":\"‚ö†Ô∏è Skipped Jobs\", \"value\":\"\"}, {\"name\":\"\", \"value\":\"$(echo -e "$SKIPPED_JOBS" | sed 's/"/\\"/g')\"}"
          [[ -n "$OPTIONAL_FAILED_JOBS" ]] && FACTS+=", {\"name\":\"‚ùå Failed (Optional)\", \"value\":\"\"}, {\"name\":\"\", \"value\":\"$(echo -e "$OPTIONAL_FAILED_JOBS" | sed 's/"/\\"/g')\"}"
 
          FACTS+="]"
 
          JSON_PAYLOAD=$(cat <<EOF
          {
            "@type": "MessageCard",
            "@context": "https://schema.org/extensions",
            "summary": "$TITLE",
            "themeColor": "$COLOR",
            "title": "$TITLE",
            "sections": [
              {
                "activityTitle": "**Repository: ${{ github.repository }}**",
                "facts": $FACTS
              }
            ]
          }
          EOF
          )
 
          curl -s -f -H 'Content-Type: application/json' \
            -d "$JSON_PAYLOAD" \
            "${{ env.TEAMS_WEBHOOK_URL }}"

  deploy-apis-to-apim:
    name: Deploy APIM API
    # environment: dev-integration
    runs-on: [self-hosted, linux]
    needs:
      - prepare-workspace
      - determine_apis
      - pre-deploy-notify
    env:
      WORKSPACE: ${{ needs.prepare-workspace.outputs.workspace-path }}
      DEPLOY_APIS: ${{ needs.determine_apis.outputs.apis-to-deploy }}
      APIM_ENV: ${{ inputs.environment }}
    strategy:
      max-parallel: 1
    steps:
      - name: Install apictl
        working-directory: ${{ env.WORKSPACE }}
        run: |
          pwd
          echo $RUNNER_WORKSPACE
          WORK_DIR="$RUNNER_WORKSPACE/apictl-4.1.6"
          mkdir -p "$WORK_DIR"
 
          if [ ! -f "$WORK_DIR/apictl/apictl" ]; then
            cd "$WORK_DIR"
            echo "Downloading apictl to $WORK_DIR..."
            wget "https://github.com/wso2/product-apim-tooling/releases/download/v4.1.6/apictl-4.1.6-linux-amd64.tar.gz"
            tar -xvzf apictl-4.1.6-linux-amd64.tar.gz
          fi
          chmod +x "$WORK_DIR/apictl/apictl"
 
          echo "$WORK_DIR/apictl" >> $GITHUB_PATH
          echo "apictl path added to PATH: $WORK_DIR"

      - name: Verify apictl version
        run: apictl version

      - name: Add Environment
        shell: bash
        run: |
          case "${{ github.event.inputs.environment }}" in
            "Dev")
              APIM_ENV_URL=${{ secrets.APIM_ENV_URL_DEV }}
              TOKEN=${{ secrets.TOKEN_DEV }}
              ;;
            "SIT")
              APIM_ENV_URL=${{ secrets.APIM_ENV_URL_SIT }}
              TOKEN=${{ secrets.TOKEN_SIT }}
              ;;
            "SIT-sandbox")
              APIM_ENV_URL=${{ secrets.APIM_ENV_URL_SIT_SANDBOX }}
              TOKEN=${{ secrets.TOKEN_SIT_SANDBOX }}
              ;;
            "UAT-node-1")
               APIM_ENV_URL=${{ secrets.APIM_ENV_URL_UAT_NODE_1 }}
               TOKEN=${{ secrets.TOKEN_UAT_NODE_1 }}
               ;;
            "UAT-node-2")
              APIM_ENV_URL=${{ secrets.APIM_ENV_URL_UAT_NODE_2 }}
              TOKEN=${{ secrets.TOKEN_UAT_NODE_2 }}
              ;;
            "STG-sandbox")
              APIM_ENV_URL=${{ secrets.APIM_ENV_URL_STG_SANDBOX }}
              TOKEN=${{ secrets.TOKEN_STG_SANDBOX }}
              ;;
            *)
              echo "‚ùå Unknown environment"
              exit 1
              ;;
          esac

          if apictl get envs | grep -q "${{ env.APIM_ENV }}"; then
            echo "Environment '${{ env.APIM_ENV }}' already exists. Skipping."
          else
            apictl add env ${{ env.APIM_ENV }} --apim https://$APIM_ENV_URL
          fi
       
      - name: Deploy API Artifacts
        id: prepareApiForDeployment
        working-directory: ${{ env.WORKSPACE }}
        run: |
          set -euo pipefail
     
          # Increase apictl timeout
          apictl set --http-request-timeout 300000
     
          # Set credentials based on environment
          case "${{ github.event.inputs.environment }}" in
            "Dev")
              APIM_USERNAME=${{ secrets.APIM_USERNAME_DEV }}
              APIM_PASSWORD=${{ secrets.APIM_PASSWORD_DEV }}
              ;;
            "SIT")
              APIM_USERNAME=${{ secrets.APIM_USERNAME_SIT }}
              APIM_PASSWORD=${{ secrets.APIM_PASSWORD_SIT }}
              ;;
            "SIT-sandbox")
              APIM_USERNAME=${{ secrets.APIM_USERNAME_SIT_SANDBOX }}
              APIM_PASSWORD=${{ secrets.APIM_PASSWORD_SIT_SANDBOX }}
              ;;
            "UAT-node-1")
              APIM_USERNAME=${{ secrets.APIM_USERNAME_UAT_NODE_1 }}
              APIM_PASSWORD=${{ secrets.APIM_PASSWORD_UAT_NODE_1 }}
              ;;
            "UAT-node-2")
              APIM_USERNAME=${{ secrets.APIM_USERNAME_UAT_NODE_2 }}
              APIM_PASSWORD=${{ secrets.APIM_PASSWORD_UAT_NODE_2 }}
              ;;
            "STG-sandbox")
              APIM_USERNAME=${{ secrets.APIM_USERNAME_STG_SANDBOX }}
              APIM_PASSWORD=${{ secrets.APIM_PASSWORD_STG_SANDBOX }}
              ;;
            *)
              echo "‚ùå Unknown environment"
              exit 1
              ;;
          esac
     
          # Login to APIM
          apictl login "${{ env.APIM_ENV }}" -u "$APIM_USERNAME" -p "$APIM_PASSWORD" -k --verbose
     
          echo "üìÅ APIs to deploy:"
          echo "${{ env.DEPLOY_APIS }}"
     
          # Split DEPLOY_APIS by newline
          IFS=$'\n'
          for api in $DEPLOY_APIS; do
            api=$(echo "$api" | xargs)  # trim spaces
            echo "üöÄ Deploying API: $api"
     
            if apictl import api \
              -f "${{ env.WORKSPACE }}/release_content/apis/${{ env.APIM_ENV }}/$api" \
              -e "${{ env.APIM_ENV }}" \
              -k \
              --rotate-revision \
              --verbose; then
                echo "‚úÖ Imported $api successfully"
            else
                echo "‚ùå Failed to import $api"
                echo "üîç Error details logged above"
                # Continue to next API
            fi
     
            sleep 5
          done

  verify-deployed-apis:
    name: Verify Deployed APIs are Published
    runs-on: [self-hosted, linux]
    needs:
      - deploy-apis-to-apim
    env:
      DEPLOY_APIS: ${{ needs.validate-api-artifacts.outputs.DEPLOY_APIS }}
      APIM_ENV: ${{ inputs.environment }}
    outputs:
      deployment_status: ${{ steps.set_status.outputs.status }}
      deployment_message: ${{ steps.set_status.outputs.message }}
    steps:
      - name: Determine APIM Host, Username, and Password based on Environment
        id: set-apim-vars
        shell: bash
        run: |
          case "${{ env.APIM_ENV }}" in
            Dev)
              APIM_HOST="${{ secrets.APIM_ENV_URL_DEV }}"
              APIM_USERNAME="${{ secrets.APIM_USERNAME_DEV }}"
              APIM_PASSWORD="${{ secrets.APIM_PASSWORD_DEV }}"
              ;;
            SIT)
              APIM_HOST="${{ secrets.APIM_ENV_URL_SIT }}"
              APIM_USERNAME="${{ secrets.APIM_USERNAME_SIT }}"
              APIM_PASSWORD="${{ secrets.APIM_PASSWORD_SIT }}"
              ;;
            SIT-sandbox)
              APIM_HOST="${{ secrets.APIM_ENV_URL_SIT_SANDBOX }}"
              APIM_USERNAME="${{ secrets.APIM_USERNAME_SIT_SANDBOX }}"
              APIM_PASSWORD="${{ secrets.APIM_PASSWORD_SIT_SANDBOX }}"
              ;;
            UAT-node-1)
              APIM_HOST="${{ secrets.APIM_ENV_URL_UAT_NODE_1 }}"
              APIM_USERNAME="${{ secrets.APIM_USERNAME_UAT_NODE_1 }}"
              APIM_PASSWORD="${{ secrets.APIM_PASSWORD_UAT_NODE_1 }}"
              ;;
            UAT-node-2)
              APIM_HOST="${{ secrets.APIM_ENV_URL_UAT_NODE_2 }}"
              APIM_USERNAME="${{ secrets.APIM_USERNAME_UAT_NODE_2 }}"
              APIM_PASSWORD="${{ secrets.APIM_PASSWORD_UAT_NODE_2 }}"
              ;;
            STG-sandbox)
              APIM_HOST="${{ secrets.APIM_ENV_URL_STG_SANDBOX }}"
              APIM_USERNAME="${{ secrets.APIM_USERNAME_STG_SANDBOX }}"
              APIM_PASSWORD="${{ secrets.APIM_PASSWORD_STG_SANDBOX }}"
              ;;
            *)
              echo "‚ùå Unknown APIM_ENV: ${{ env.APIM_ENV }}"
              exit 1
              ;;
          esac
  
          echo "APIM_HOST=$APIM_HOST" >> $GITHUB_ENV
          echo "APIM_USERNAME=$APIM_USERNAME" >> $GITHUB_ENV
          echo "APIM_PASSWORD=$APIM_PASSWORD" >> $GITHUB_ENV
          echo "Using APIM_HOST: $APIM_HOST with provided credentials"
  
      - name: Install apictl
        run: |
          WORK_DIR="$RUNNER_WORKSPACE/apictl-4.1.6"
          mkdir -p "$WORK_DIR"
          if [ ! -f "$WORK_DIR/apictl/apictl" ]; then
            cd "$WORK_DIR"
            wget "https://github.com/wso2/product-apim-tooling/releases/download/v4.1.6/apictl-4.1.6-linux-amd64.tar.gz"
            tar -xvzf apictl-4.1.6-linux-amd64.tar.gz
          fi
          chmod +x "$WORK_DIR/apictl/apictl"
          echo "$WORK_DIR/apictl" >> $GITHUB_PATH
  
      - name: Login to APIM
        run: |
          apictl login "${{ env.APIM_ENV }}" -u "$APIM_USERNAME" -p "$APIM_PASSWORD" -k --verbose
  
      - name: Verify APIs are Published
        id: set_status
        shell: bash
        run: |
          IFS=',' read -ra API_LIST <<< "$DEPLOY_APIS"
          FAILED=0
          MESSAGE=""
  
          for API_NAME in "${API_LIST[@]}"; do
            echo "üîç Verifying API: $API_NAME"
            STATUS=$(apictl get api -n "$API_NAME" -e "${{ env.APIM_ENV }}" -k --verbose | jq -r '.list[0].lifeCycleStatus')
           
            if [[ "$STATUS" == "Published" ]]; then
              echo "‚úî API '$API_NAME' is in Published state."
            else
              echo "‚ùå API '$API_NAME' is NOT Published. Current state: $STATUS"
              FAILED=1
              MESSAGE+="API '$API_NAME' status: $STATUS\n"
            fi
          done
  
          if [[ $FAILED -eq 1 ]]; then
            DEPLOYMENT_STATUS="Failed"
            MESSAGE="One or more APIs are not published:\n$MESSAGE"
          else
            DEPLOYMENT_STATUS="Success"
            MESSAGE="All deployed APIs are in Published state."
          fi
  
          echo "Deployment status: $DEPLOYMENT_STATUS"
          echo "Deployment message: $MESSAGE"
  
          echo "::set-output name=status::$DEPLOYMENT_STATUS"
          echo "::set-output name=message::$MESSAGE"
  
          if [[ $FAILED -eq 1 ]]; then
            exit 1
          fi

  notify-deployment-status:
    name: Teams Deployment Notification
    runs-on: ubuntu-latest
    needs:
      - verify-deployed-apis
    if: always()
    env:
      TEAMS_WEBHOOK_URL: ${{ secrets.TEAMS_WEBHOOK_URL }}
      RELEASE_VERSION: ${{ inputs.releaseVersion }}
      DEPLOY_STATUS: ${{ needs.verify-deployed-apis.outputs.deployment_status }}
      DEPLOY_MESSAGE: ${{ needs.verify-deployed-apis.outputs.deployment_message }}
      DEPLOY_APIS: ${{ needs.validate-api-artifacts.outputs.DEPLOY_APIS }}
  
    steps:
      - name: Notify Deployment Status
        run: |
  
          echo "APIs: $DEPLOY_APIS"
          echo "Status: $DEPLOY_STATUS"
          echo "Message: $DEPLOY_MESSAGE"
  
          set -euo pipefail
  
          TITLE=""
          COLOR=""
          PASSED_APIS=""
          FAILED_APIS=""
  
          pretty_api_list() {
            echo "$1" | tr ',' '\n'
          }
  
          # Build passed/failed API sections
          IFS=',' read -ra API_LIST <<< "$DEPLOY_APIS"
  
          for API in "${API_LIST[@]}"; do
            if grep -q "$API" <<< "$DEPLOY_MESSAGE"; then
              FAILED_APIS+="- ‚ùå $API\n"
            else
              PASSED_APIS+="- ‚úÖ $API\n"
            fi
          done
  
          if [[ "$DEPLOY_STATUS" == "Success" ]]; then
            TITLE="‚úÖ Deployment Verification: All APIs Published"
            COLOR="2E8B57"
          else
            TITLE="‚ùå Deployment Verification: Some APIs Not Published"
            COLOR="B22222"
          fi
  
          FACTS="[ \
            {\"name\":\"üìã Workflow:\", \"value\":\"${{ github.workflow }}\"}, \
            {\"name\":\"üåø Branch:\", \"value\":\"${{ github.ref_name }}\"}, \
            {\"name\":\"üîó Commit:\", \"value\":\"${{ github.sha }}\"}, \
            {\"name\":\"üë§ Initiated By:\", \"value\":\"${{ github.actor }}\"}, \
            {\"name\":\"üè∑Ô∏è Release Version:\", \"value\":\"${{ env.RELEASE_VERSION }}\"}, \
            {\"name\":\"üìÇ APIs Verified:\", \"value\":\"\"}, \
            {\"name\":\"\", \"value\":\"$(echo -e "$(pretty_api_list "$DEPLOY_APIS")" | sed 's/"/\\"/g')\"} \
          "
  
          [[ -n "$PASSED_APIS" ]] && FACTS+=", {\"name\":\"‚úÖ Published APIs\", \"value\":\"\"}, {\"name\":\"\", \"value\":\"$(echo -e "$PASSED_APIS" | sed 's/"/\\"/g')\"}"
          [[ -n "$FAILED_APIS" ]] && FACTS+=", {\"name\":\"‚ùå APIs Not Published\", \"value\":\"\"}, {\"name\":\"\", \"value\":\"$(echo -e "$FAILED_APIS" | sed 's/"/\\"/g')\"}"
  
          FACTS+="]"
  
          JSON_PAYLOAD=$(cat <<EOF
          {
            "@type": "MessageCard",
            "@context": "https://schema.org/extensions",
            "summary": "$TITLE",
            "themeColor": "$COLOR",
            "title": "$TITLE",
            "sections": [
              {
                "activityTitle": "**Repository: ${{ github.repository }}**",
                "facts": $FACTS
              },
              {
                "text": "**Status Message:**\n\n${DEPLOY_MESSAGE//$'\n'/<br>}"
              }
            ]
          }
          EOF
          )
  
          echo "Sending Teams notification..."
          curl -s -f -H 'Content-Type: application/json' \
            -d "$JSON_PAYLOAD" \
            "$TEAMS_WEBHOOK_URL"




===============


https://apim.docs.wso2.com/en/3.1.0/develop/customizations/customizing-the-developer-portal/customize-api-listing/categorizing-and-grouping-apis/api-category-based-grouping/










=====================







      - name: Install jq
        working-directory: ${{ env.WORKSPACE }}
        run: |
          echo "Installing jq locally..."
          JQ_DIR="$RUNNER_WORKSPACE/jq"
          mkdir -p "$JQ_DIR"

          if [ ! -f "$JQ_DIR/jq" ]; then
            echo "Downloading jq binary..."
            wget -O "$JQ_DIR/jq" https://github.com/jqlang/jq/releases/download/jq-1.7.1/jq-linux-amd64
            chmod +x "$JQ_DIR/jq"
          else
            echo "jq already exists at $JQ_DIR/jq"
          fi

          # Add jq to PATH so later workflow steps can use it
          echo "$JQ_DIR" >> $GITHUB_PATH
          echo "jq path added: $JQ_DIR"

          # Display the installed jq version to confirm successful installation
          echo "jq version: $($JQ_DIR/jq --version)"



===========





STATUS=$(apictl get apis "$API_NAME" -e "${{ env.APIM_ENV }}" -k \
  | awk -v api="$API_NAME" '$2 == api {print $5}')




==================================



      - name: Verify APIs are Published
        id: set_status
        shell: bash
        run: |
          IFS=',' read -ra API_LIST <<< "${{ env.DEPLOY_APIS }}"
          FAILED=0
          MESSAGE=""
          not_deployed_apis=()

          for API_NAME in "${API_LIST[@]}"; do
            echo "üîç Verifying API: $API_NAME"
            
            # Get current status
            STATUS=$(apictl get apis "$API_NAME" -e "${{ env.APIM_ENV }}" -k \
              | awk -v api="$API_NAME" '$2 == api {print $5}')

            echo "Current status of $API_NAME: $STATUS"

            if [[ "$STATUS" == "PUBLISHED" ]]; then
              echo "‚úÖ $API_NAME is already published."

            elif [[ "$STATUS" == "CREATED" ]]; then
              echo "‚ö° $API_NAME is in CREATED state. Publishing..."
              apictl publish api "$API_NAME" -e "${{ env.APIM_ENV }}" -k
              if [[ $? -eq 0 ]]; then
                echo "‚úÖ $API_NAME published successfully."
              else
                echo "‚ùå Failed to publish $API_NAME."
                not_deployed_apis+=("$API_NAME")
              fi

            else
              echo "‚ùå $API_NAME is in unexpected state: $STATUS"
              not_deployed_apis+=("$API_NAME")
            fi
          done

          # Export the not deployed APIs as an output variable for further steps
          if [[ ${#not_deployed_apis[@]} -ne 0 ]]; then
            echo "APIS_NOT_DEPLOYED=${not_deployed_apis[*]}" >> $GITHUB_ENV
            echo "‚ö†Ô∏è Some APIs were not deployed: ${not_deployed_apis[*]}"
          else
            echo "‚úÖ All APIs are published."
          fi



======================


We can fix this by using grep + awk more reliably:

STATUS=$(apictl get apis "$API_NAME" -e "${{ env.APIM_ENV }}" -k \
         | grep -w "$API_NAME" | awk '{print $5}')


Or, a more bulletproof approach skipping the header and trimming spaces:

STATUS=$(apictl get apis "$API_NAME" -e "${{ env.APIM_ENV }}" -k \
         | tail -n +2 \
         | awk -v api="$API_NAME" '$2 == api {print $5}')


===


apictl get apis --environment dev --output table | grep "PhoneVerification" | awk '{print $6}'



==================


Option B ‚Äî Output comma-separated in determine_apis

Instead of:

ZIP_FILES=$(printf "%s\n" "${VALID_ZIPS[@]}")


Do:

ZIP_FILES=$(IFS=','; echo "${VALID_ZIPS[*]}")


Then your IFS=',' read -ra API_LIST in verify-deployed-apis will work as expected.



=================


# Initialize array
API_LIST=()

# Read DEPLOY_APIS line by line
while IFS= read -r line || [ -n "$line" ]; do
  API_LIST+=("$line")
done <<< "${{ env.DEPLOY_APIS }}"
