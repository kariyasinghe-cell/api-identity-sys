name: Reusable workflow for deploying APIM APIs

on:
  workflow_call:
    inputs:
      includeAPIs:
        description: 'Comma-separated list of APIM APIs to include'
        required: true
        type: string
       
      releaseVersion:
        description: 'The Git release version which use with the enviorenment'
        required: true
        type: string

      triggeredBy:
        description: "Flag to indicate this is from child workflow"
        required: false
        default: "false"
        type: string
       
      environment:
        description: "API Deployment Environment"
        required: false
        default: "Dev"
        type: string
       
jobs:
  prepare-workspace:
    name: Define Workspace
    runs-on: [self-hosted, linux]
    outputs:
      workspace-path: ${{ steps.define_workspace.outputs.workspace }}
    steps:
      - name: Define Workspace
        id: define_workspace
        run: |
          WS="${{ github.workspace }}/${{ github.run_id }}-ci"
          mkdir -p "$WS"
          echo "workspace=$WS" >> $GITHUB_OUTPUT
          echo "Workspace directory created: $WS"
         
  determine_apis:
    name: Determine APIs to process
    runs-on: ubuntu-latest
    needs:
      - prepare-workspace
    outputs:
      apis-to-deploy: ${{ steps.detect_apis.outputs.zip_files }}

    steps:
      - name: Download GitHub Release ZIP
        id: download_release
        run: |
          set -e

          RELEASE_VERSION="${{ inputs.releaseVersion }}"
          RELEASE_FILE="${RELEASE_VERSION}-release-apis.zip"
          RELEASE_URL="https://github.com/sampathbankplc/middleware-apim-sampathvishwa-app-apis/releases/download/${RELEASE_VERSION}/${RELEASE_FILE}"

          echo "Downloading release ZIP: $RELEASE_URL"
          curl -L -o release.zip "$RELEASE_URL"

          echo "Extracting release.zip..."
          unzip -q release.zip -d release_content

      - name: Determine APIs to deploy
        id: detect_apis
        run: |
          set -e

          INPUT="${{ inputs.includeAPIs }}"
          TRIGGERED_BY="${{ inputs.triggeredBy }}"
          ENV_PATH="apis/${{ env.APIM_ENV }}"

          API_ROOT="release_content/${ENV_PATH}"

          if [ ! -d "$API_ROOT" ]; then
            echo "‚ùå ERROR: Directory '$API_ROOT' not found in release!"
            exit 1
          fi

          echo "üìÅ Looking for API ZIPs inside: $API_ROOT"

          to_zip() {
            local api="$1"
            if [[ "$api" == *.zip ]]; then
              echo "$api"
            else
              echo "${api}.zip"
            fi
          }

          if [ -z "$INPUT" ] && [ "$TRIGGERED_BY" == "developer" ]; then
            echo "‚ùå Developer trigger but no includeAPIs input ‚Äî stopping pipeline"
            exit 1

          elif [ -z "$INPUT" ] && [ "$TRIGGERED_BY" == "apim-team" ]; then
            echo "‚öôÔ∏è APIM team trigger ‚Äî including ALL ZIPs from the release"
            ZIP_FILES=$(ls -1 "$API_ROOT"/*.zip 2>/dev/null | xargs -n1 basename)

          else
            echo "User input APIs: $INPUT"
            IFS=',' read -r -a ARR <<< "$INPUT"

            VALID_ZIPS=()
            INVALID_ZIPS=()

            for api in "${ARR[@]}"; do
              api=$(echo "$api" | xargs)
              zip_file=$(to_zip "$api")

              if [ -f "$API_ROOT/$zip_file" ]; then
                VALID_ZIPS+=("$zip_file")
              else
                INVALID_ZIPS+=("$zip_file")
              fi
            done

            if [ ${#INVALID_ZIPS[@]} -ne 0 ]; then
              echo "‚ö†Ô∏è WARNING: These ZIP files do NOT exist in the release: ${INVALID_ZIPS[*]}"
            fi

            if [ ${#VALID_ZIPS[@]} -eq 0 ]; then
              echo "‚ùå No valid APIs found in release for input!"
              exit 1
            fi

            ZIP_FILES="${VALID_ZIPS[*]}"
          fi

          echo "‚úÖ Final ZIP files to deploy: $ZIP_FILES"

          {
            echo "zip_files<<EOF"
            echo "$ZIP_FILES"
            echo "EOF"
          } >> "$GITHUB_OUTPUT"


  validate-api-artifacts:
    name: Validate API Preconditions
    runs-on: [self-hosted, linux]
    needs:
      - determine_apis
    env:
      DEPLOY_APIS: ${{ needs.determine_apis.outputs.apis-to-deploy }}
      APIM_ENV: ${{ inputs.environment }}
    steps:

      - uses: actions/checkout@v4
        with:
          repository: sampathbankplc/middleware-apim-sampathvishwa-app-apis
          fetch-depth: 5
          path: repo

      - name: Install yq
        working-directory: ${{ env.WORKSPACE }}
        run: |
          WORK_DIR="$RUNNER_WORKSPACE/yq"
          mkdir -p "$WORK_DIR"
     
          if [ ! -f "$WORK_DIR/yq" ]; then
            cd "$WORK_DIR"
            echo "Downloading yq to $WORK_DIR..."
            wget "https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64" -O yq
          fi
     
          chmod +x "$WORK_DIR/yq"
          echo "$WORK_DIR" >> $GITHUB_PATH
          echo "yq path added to PATH: $WORK_DIR"

      - name: Install apictl
        working-directory: ${{ env.WORKSPACE }}
        run: |
          echo $RUNNER_WORKSPACE
          WORK_DIR="$RUNNER_WORKSPACE/apictl-4.1.6"
          mkdir -p "$WORK_DIR"
 
          if [ ! -f "$WORK_DIR/apictl/apictl" ]; then
            cd "$WORK_DIR"
            echo "Downloading apictl to $WORK_DIR..."
            wget "https://github.com/wso2/product-apim-tooling/releases/download/v4.1.6/apictl-4.1.6-linux-amd64.tar.gz"
            tar -xvzf apictl-4.1.6-linux-amd64.tar.gz
          fi
          chmod +x "$WORK_DIR/apictl/apictl"
 
          echo "$WORK_DIR/apictl" >> $GITHUB_PATH
          echo "apictl path added to PATH: $WORK_DIR"

      - name: Verify apictl version
        run: apictl version

      # - name: Validate API ZIPs
      #   id: validate_apis
      #   working-directory: repo
      #   run: |
      #     echo "Analyzing APIs: $DEPLOY_APIS"
      #     mkdir -p extracted
         
      #     VALIDATION_ERRORS=0
         
      #     echo "-------------------------------------------------------"
      #     echo "üìå Fetching data from APIM"
      #     echo "-------------------------------------------------------"
         
      #     APIM_ROLES=$(apictl get roles -e $APIM_ENV -k | awk '{print $1}' | tail -n +3)
      #     APIM_POLICIES=$(apictl get policies -e $APIM_ENV -k | awk '{print $1}' | tail -n +3)
      #     APIM_LABELS=$(apictl get gateways -e $APIM_ENV -k | awk '{print $1}' | tail -n +3)
      #     APIM_CATEGORIES=$(apictl get api-categories -e $APIM_ENV -k | awk '{print $1}' | tail -n +3)

      #     APIM_ROLES=$(apictl get roles -k | awk '{print $1}' | tail -n +3)
      #     APIM_POLICIES=$(apictl get policies -k | awk '{print $1}' | tail -n +3)
      #     APIM_LABELS=$(apictl get gateways -k | awk '{print $1}' | tail -n +3)
      #     APIM_CATEGORIES=$(apictl get api-categories -k | awk '{print $1}' | tail -n +3)
         
      #     echo "APIM ‚Üí Roles:"
      #     echo "$APIM_ROLES"
      #     echo
      #     echo "APIM ‚Üí Policies:"
      #     echo "$APIM_POLICIES"
      #     echo
      #     echo "APIM ‚Üí Gateway Labels:"
      #     echo "$APIM_LABELS"
      #     echo
      #     echo "APIM ‚Üí API Categories:"
      #     echo "$APIM_CATEGORIES"
      #     echo "-------------------------------------------------------"
         
         
      #     for api in $DEPLOY_APIS; do
      #       echo
      #       echo "======================================================="
      #       echo "üîç Validating ZIP: $api"
      #       echo "======================================================="
         
      #       unzip -o "apim/$api" -d "extracted/$api" >/dev/null
         
      #       # Detect inner folder containing api.yaml
      #       INNER_DIR=$(find "extracted/$api" -type f -name "api.yaml" -printf '%h')
      #       API_YAML="$INNER_DIR/api.yaml"
         
      #       if [[ ! -f "$API_YAML" ]]; then
      #         echo "‚ùå api.yaml missing inside zip: $api"
      #         VALIDATION_ERRORS=$((VALIDATION_ERRORS+1))
      #         continue
      #       fi
         
      #       echo "üìÑ Found api.yaml at: $API_YAML"
      #       echo
         
      #       echo "-------------------------------------------------------"
      #       echo "üìå API ZIP ‚Üí Extracting Info"
      #       echo "-------------------------------------------------------"
         
      #       # 1Ô∏è‚É£ Roles from scopes
      #       ZIP_ROLES=$(yq e '.scopes[].roles // ""' "$API_YAML" | tr ',' '\n' | xargs -I {} echo {} | sort -u)
      #       echo "ZIP ‚Üí Roles:"
      #       echo "${ZIP_ROLES:-None}"
      #       echo
         
      #       # 2Ô∏è‚É£ Policies
      #       ZIP_POLICIES=$(yq e '.throttlingPolicy, .subscriptionPolicies[], .applicationPolicies[]?' "$API_YAML" | grep -v null || true)
      #       echo "ZIP ‚Üí Policies:"
      #       echo "${ZIP_POLICIES:-None}"
      #       echo
         
      #       # 3Ô∏è‚É£ Gateway Labels
      #       ZIP_LABELS=$(yq e '.gatewayLabels[]?' "$API_YAML" || true)
      #       echo "ZIP ‚Üí Gateway Labels:"
      #       echo "${ZIP_LABELS:-None}"
      #       echo
         
      #       # 4Ô∏è‚É£ API Categories
      #       ZIP_CATEGORIES=$(yq e '.categories[]?' "$API_YAML" || true)
      #       echo "ZIP ‚Üí API Categories:"
      #       echo "${ZIP_CATEGORIES:-None}"
      #       echo
         
      #       # 5Ô∏è‚É£ Extract endpoints
      #       ZIP_ENDPOINTS=$(yq e '.endpointConfig.*.url?' "$API_YAML" || true)
      #       echo "ZIP ‚Üí Endpoints:"
      #       echo "${ZIP_ENDPOINTS:-None}"
      #       echo
         
      #       echo "-------------------------------------------------------"
      #       echo "üìå Comparing: ZIP vs APIM"
      #       echo "-------------------------------------------------------"
         
      #       # Compare roles
      #       for ROLE in $ZIP_ROLES; do
      #         if ! echo "$APIM_ROLES" | grep -qw "$ROLE"; then
      #           echo "‚ö†Ô∏è Missing Role in APIM: $ROLE"
      #         else
      #           echo "‚úî Role exists: $ROLE"
      #         fi
      #       done
      #       echo
         
      #       # Compare policies
      #       for P in $ZIP_POLICIES; do
      #         if ! echo "$APIM_POLICIES" | grep -qw "$P"; then
      #           echo "‚ö†Ô∏è Missing Policy in APIM: $P"
      #         else
      #           echo "‚úî Policy exists: $P"
      #         fi
      #       done
      #       echo
         
      #       # Compare labels
      #       for L in $ZIP_LABELS; do
      #         if ! echo "$APIM_LABELS" | grep -qw "$L"; then
      #           echo "‚ö†Ô∏è Missing Gateway Label in APIM: $L"
      #         else
      #           echo "‚úî Gateway Label exists: $L"
      #         fi
      #       done
      #       echo
         
      #       # Compare categories
      #       for C in $ZIP_CATEGORIES; do
      #         if ! echo "$APIM_CATEGORIES" | grep -qw "$C"; then
      #           echo "‚ö†Ô∏è Missing API Category in APIM: $C"
      #         else
      #           echo "‚úî API Category exists: $C"
      #         fi
      #       done
      #       echo
         
      #       # Check Endpoint Certificates
      #       for E in $ZIP_ENDPOINTS; do
      #         HOST=$(echo "$E" | sed -E 's@https?://([^:/]+).*@\1@')
      #         if keytool -printcert -rfc -sslserver "$HOST" >/dev/null 2>&1; then
      #           echo "‚úî Endpoint cert valid: $HOST"
      #         else
      #           echo "‚ö†Ô∏è Endpoint cert NOT trusted: $HOST"
      #         fi
      #       done
         
      #     done
         
      #     echo "VALIDATION_ERRORS=$VALIDATION_ERRORS" >> $GITHUB_OUTPUT

  pre-deploy-notify:
    name: Notify Deployment Status
    runs-on: ubuntu-latest
    needs:
      - determine_apis
      # - validate-api-artifacts
    if: always()
    env:
      TEAMS_WEBHOOK_URL: ${{ secrets.TEAMS_WEBHOOK_URL }}
      DEPLOY_APIS: ${{ needs.determine_apis.outputs.apis-to-deploy }}
     
    steps:
      - name: Notify Deployment Status
        run: |

          echo "${{ env.DEPLOY_APIS }}"
         
          set -euo pipefail
          TITLE=""
          COLOR=""
          PASSED_JOBS=""
          FAILED_JOBS=""
          SKIPPED_JOBS=""
          OPTIONAL_FAILED_JOBS=""
 
          prettify() {
            echo "$1" | sed -E 's/([a-z])([A-Z])/\1 \2/g'
          }
 
          pad_right() {
            printf "%-30s" "$1"
          }
 
          NEEDS_JSON='${{ toJson(needs) }}'
 
          echo "Fetching job results..."
          for job in $(jq -r 'keys[]' <<< "$NEEDS_JSON"); do
            RESULT=$(jq -r ".\"$job\".result" <<< "$NEEDS_JSON")
            JOB_NAME=$(prettify "$job")
            PADDED_JOB_NAME=$(pad_right "$JOB_NAME")
 
            if [[ "$RESULT" == "success" ]]; then
              PASSED_JOBS+="- ‚úÖ $PADDED_JOB_NAME\n"
            elif [[ "$RESULT" == "failure" ]]; then
              FAILED_JOBS+="- ‚ùå $PADDED_JOB_NAME\n"
            else
              SKIPPED_JOBS+="- ‚ö†Ô∏è $PADDED_JOB_NAME\n"
            fi
          done
 
          if [[ -z "$FAILED_JOBS" && -z "$SKIPPED_JOBS" ]]; then
            TITLE="‚úÖ Pre-Deployment Verification: Success | Deployment Ready"
            COLOR="2E8B57"
          else
            TITLE="‚ùå Pre-Deployment Verification: Failed | Deployment Blocked"
            COLOR="B22222"
          fi
 
          FACTS="[ \
            {\"name\":\"üìã Workflow:\", \"value\":\"${{ github.workflow }}\"}, \
            {\"name\":\"üåø Branch:\", \"value\":\"${{ github.ref_name }}\"}, \
            {\"name\":\"üîó Commit:\", \"value\":\"${{ github.sha }}\"}, \
            {\"name\":\"üë§ Initiated By:\", \"value\":\"${{ github.actor }}\"} \
          "
 
          [[ -n "$PASSED_JOBS" ]] && FACTS+=", {\"name\":\"‚úÖ Passed Jobs\", \"value\":\"\"}, {\"name\":\"\", \"value\":\"$(echo -e "$PASSED_JOBS" | sed 's/"/\\"/g')\"}"
          [[ -n "$FAILED_JOBS" ]] && FACTS+=", {\"name\":\"‚ùå Failed Jobs\", \"value\":\"\"}, {\"name\":\"\", \"value\":\"$(echo -e "$FAILED_JOBS" | sed 's/"/\\"/g')\"}"
          [[ -n "$SKIPPED_JOBS" ]] && FACTS+=", {\"name\":\"‚ö†Ô∏è Skipped Jobs\", \"value\":\"\"}, {\"name\":\"\", \"value\":\"$(echo -e "$SKIPPED_JOBS" | sed 's/"/\\"/g')\"}"
          [[ -n "$OPTIONAL_FAILED_JOBS" ]] && FACTS+=", {\"name\":\"‚ùå Failed (Optional)\", \"value\":\"\"}, {\"name\":\"\", \"value\":\"$(echo -e "$OPTIONAL_FAILED_JOBS" | sed 's/"/\\"/g')\"}"
 
          FACTS+="]"
 
          JSON_PAYLOAD=$(cat <<EOF
          {
            "@type": "MessageCard",
            "@context": "https://schema.org/extensions",
            "summary": "$TITLE",
            "themeColor": "$COLOR",
            "title": "$TITLE",
            "sections": [
              {
                "activityTitle": "**Repository: ${{ github.repository }}**",
                "facts": $FACTS
              }
            ]
          }
          EOF
          )
 
          curl -s -f -H 'Content-Type: application/json' \
            -d "$JSON_PAYLOAD" \
            "${{ env.TEAMS_WEBHOOK_URL }}"

  deploy-apis-to-apim:
    name: Deploy APIM API
    environment: dev-integration
    runs-on: [self-hosted, linux]
    needs:
      - prepare-workspace
      - determine_apis
      - pre-deploy-notify
    env:
      WORKSPACE: ${{ needs.prepare-workspace.outputs.workspace-path }}
      DEPLOY_APIS: ${{ needs.determine_apis.outputs.apis-to-deploy }}
      APIM_ENV: ${{ inputs.environment }}
    strategy:
      max-parallel: 1
    steps:
      - name: Install apictl
        working-directory: ${{ env.WORKSPACE }}
        run: |
          echo $RUNNER_WORKSPACE
          WORK_DIR="$RUNNER_WORKSPACE/apictl-4.1.6"
          mkdir -p "$WORK_DIR"
 
          if [ ! -f "$WORK_DIR/apictl/apictl" ]; then
            cd "$WORK_DIR"
            echo "Downloading apictl to $WORK_DIR..."
            wget "https://github.com/wso2/product-apim-tooling/releases/download/v4.1.6/apictl-4.1.6-linux-amd64.tar.gz"
            tar -xvzf apictl-4.1.6-linux-amd64.tar.gz
          fi
          chmod +x "$WORK_DIR/apictl/apictl"
 
          echo "$WORK_DIR/apictl" >> $GITHUB_PATH
          echo "apictl path added to PATH: $WORK_DIR"

      - name: Verify apictl version
        run: apictl version

      - name: Add Environment
        shell: bash
        run: |
          case "${{ github.event.inputs.environment }}" in
            "Dev")
              APIM_ENV_URL=${{ secrets.APIM_ENV_URL_DEV }}
              ;;
            "SIT")
              APIM_ENV_URL=${{ secrets.APIM_ENV_URL_SIT }}
              ;;
            "SIT-sandbox")
              APIM_ENV_URL=${{ secrets.APIM_ENV_URL_SIT_SANDBOX }}
              ;;
            "UAT-node-1")
               APIM_ENV_URL=${{ secrets.APIM_ENV_URL_UAT_NODE_1 }}
               ;;
            "UAT-node-2")
              APIM_ENV_URL=${{ secrets.APIM_ENV_URL_UAT_NODE_2 }}
              ;;
            "STG-sandbox")
              APIM_ENV_URL=${{ secrets.APIM_ENV_URL_STG_SANDBOX }}
              ;;
            *)
              echo "‚ùå Unknown environment"
              exit 1
              ;;
          esac

          if apictl get envs | grep -q "${{ env.APIM_ENV }}"; then
            echo "Environment '${{ env.APIM_ENV }}' already exists. Skipping."
          else
            apictl add env ${{ env.APIM_ENV }} --apim https://$APIM_ENV_URL
          fi
       
      - name: Deploy API Artifacts
        id: prepareApiForDeployment
        working-directory: ${{ env.WORKSPACE }}
        run: |      
          # Increase apictl timeout
          apictl set --http-request-timeout 300000

          case "${{ github.event.inputs.environment }}" in
            "Dev")
              APIM_USERNAME=${{ secrets.APIM_USERNAME_DEV }}
              APIM_PASSWORD=${{ secrets.APIM_PASSWORD_DEV }}
              ;;
            "SIT")
              APIM_USERNAME=${{ secrets.APIM_USERNAME_SIT }}
              APIM_PASSWORD=${{ secrets.APIM_PASSWORD_SIT }}
              ;;
            "SIT-sandbox")
              APIM_USERNAME=${{ secrets.APIM_USERNAME_SIT_SANDBOX }}
              APIM_PASSWORD=${{ secrets.APIM_PASSWORD_SIT_SANDBOX }}
              ;;
            "UAT-node-1")
              APIM_USERNAME=${{ secrets.APIM_USERNAME_UAT_NODE_1 }}
              APIM_PASSWORD=${{ secrets.APIM_PASSWORD_UAT_NODE_1 }}
              ;;
            "UAT-node-2")
              APIM_USERNAME=${{ secrets.APIM_USERNAME_UAT_NODE_2 }}
              APIM_PASSWORD=${{ secrets.APIM_PASSWORD_UAT_NODE_2 }}
              ;;
            "STG-sandbox")
              APIM_USERNAME=${{ secrets.APIM_USERNAME_STG_SANDBOX }}
              APIM_PASSWORD=${{ secrets.APIM_PASSWORD_STG_SANDBOX }}
              ;;
            *)
              echo "‚ùå Unknown environment"
              exit 1
              ;;
          esac
     
          # Login to APIM
          apictl login "${{ env.APIM_ENV }}" -u "$APIM_USERNAME" -p "$APIM_PASSWORD" -k --verbose

          for api in $DEPLOY_APIS; do
            echo "üöÄ Deploying API: $api"
            if apictl import api \
              -f "${{ env.WORKSPACE }}/apim/$api" \
              -e "${{ env.APIM_ENV }}" \
              -k \
              --rotate-revision \
              --verbose; then
                echo "‚úÖ Imported $api successfully"
            else
                echo "‚ùå Failed to import $api"
                echo "üîç Error details:"
                # Capture and print error logs
                apictl import api \
                  -f "${{ env.WORKSPACE }}/apim/$api" \
                  -e "${{ env.APIM_ENV }}" \
                  -k \
                  --rotate-revision \
                  --verbose 2>&1 | tee /dev/stderr
                # Continue to next API
            fi
            sleep 5


=============================================================



- name: Download GitHub Release ZIP (Auto Asset Detection + Retry)
  id: download_release
  run: |
    set -e

    REPO="sampathbankplc/middleware-apim-sampathvishwa-app-apis"
    INPUT_VER="${{ inputs.releaseVersion }}"

    echo "üîç Requested release version: $INPUT_VER"

    # Determine release tag
    if [ "$INPUT_VER" = "latest" ]; then
      echo "üì¶ Fetching latest release metadata..."
      RELEASE_JSON=$(curl -s \
        -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
        "https://api.github.com/repos/$REPO/releases/latest")
    else
      echo "üì¶ Fetching release metadata for tag $INPUT_VER..."
      RELEASE_JSON=$(curl -s \
        -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
        "https://api.github.com/repos/$REPO/releases/tags/$INPUT_VER")
    fi

    # Extract release tag
    RELEASE_TAG=$(echo "$RELEASE_JSON" | jq -r '.tag_name')
    echo "‚úÖ Release tag resolved to: $RELEASE_TAG"

    # Expected filename pattern
    EXPECTED_FILE="${RELEASE_TAG}-release-apis.zip"

    echo "üîç Looking for asset file: $EXPECTED_FILE"

    # Extract asset ID from release assets json
    ASSET_ID=$(echo "$RELEASE_JSON" \
      | jq -r ".assets[] | select(.name == \"$EXPECTED_FILE\") | .id")

    if [ -z "$ASSET_ID" ] || [ "$ASSET_ID" = "null" ]; then
      echo "‚ùå ERROR: Could not find asset '$EXPECTED_FILE' in release '$RELEASE_TAG'"
      echo "Available assets:"
      echo "$RELEASE_JSON" | jq -r '.assets[].name'
      exit 1
    fi

    echo "üìÑ Found asset ID: $ASSET_ID"

    ASSET_URL="https://api.github.com/repos/$REPO/releases/assets/$ASSET_ID"

    echo "üåê Download URL (GitHub API): $ASSET_URL"

    # Retry logic: 3 attempts with delay
    attempt=1
    while [ $attempt -le 3 ]; do
      echo "‚¨áÔ∏è Download attempt $attempt..."

      curl -L \
        -H "Accept: application/octet-stream" \
        -H "Authorization: Bearer ${{ secrets.GITHUB_TOKEN }}" \
        -o release.zip \
        "$ASSET_URL" && break

      echo "‚ö†Ô∏è Download failed (attempt $attempt)"
      attempt=$((attempt + 1))
      sleep 2
    done

    if [ ! -f release.zip ]; then
      echo "‚ùå ERROR: Failed to download release asset after 3 attempts"
      exit 1
    fi

    echo "üìÅ Download completed. File info:"
    ls -lh release.zip
    file release.zip

    # Validate ZIP
    if ! file release.zip | grep -q "Zip archive data"; then
      echo "‚ùå ERROR: Downloaded file is NOT a zip archive"
      echo "It may be an HTML output from GitHub"
      cat release.zip | head -20 || true
      exit 1
    fi

    echo "üìÇ Extracting ZIP..."
    unzip -q release.zip -d release_content

    echo "‚úÖ Extraction finished."



====================================


elif [ -z "$INPUT" ] && [ "$TRIGGERED_BY" == "apim-team" ]; then
  echo "‚öôÔ∏è APIM team trigger ‚Äî including ALL ZIPs from the release"

  FILES=("$API_ROOT"/*.zip)

  if [ ! -e "${FILES[0]}" ]; then
    echo "‚ùå No ZIP files found in '$API_ROOT'"
    exit 1
  fi

  ZIP_FILES=$(printf "%s\n" "${FILES[@]}" | xargs -n1 basename)



=====================================



- name: Deploy API Artifacts
  id: prepareApiForDeployment
  working-directory: ${{ env.WORKSPACE }}
  run: |
    set -euo pipefail

    # Increase apictl timeout
    apictl set --http-request-timeout 300000

    # Set credentials based on environment
    case "${{ github.event.inputs.environment }}" in
      "Dev")
        APIM_USERNAME=${{ secrets.APIM_USERNAME_DEV }}
        APIM_PASSWORD=${{ secrets.APIM_PASSWORD_DEV }}
        ;;
      "SIT")
        APIM_USERNAME=${{ secrets.APIM_USERNAME_SIT }}
        APIM_PASSWORD=${{ secrets.APIM_PASSWORD_SIT }}
        ;;
      "SIT-sandbox")
        APIM_USERNAME=${{ secrets.APIM_USERNAME_SIT_SANDBOX }}
        APIM_PASSWORD=${{ secrets.APIM_PASSWORD_SIT_SANDBOX }}
        ;;
      "UAT-node-1")
        APIM_USERNAME=${{ secrets.APIM_USERNAME_UAT_NODE_1 }}
        APIM_PASSWORD=${{ secrets.APIM_PASSWORD_UAT_NODE_1 }}
        ;;
      "UAT-node-2")
        APIM_USERNAME=${{ secrets.APIM_USERNAME_UAT_NODE_2 }}
        APIM_PASSWORD=${{ secrets.APIM_PASSWORD_UAT_NODE_2 }}
        ;;
      "STG-sandbox")
        APIM_USERNAME=${{ secrets.APIM_USERNAME_STG_SANDBOX }}
        APIM_PASSWORD=${{ secrets.APIM_PASSWORD_STG_SANDBOX }}
        ;;
      *)
        echo "‚ùå Unknown environment"
        exit 1
        ;;
    esac

    # Login to APIM
    apictl login "${{ env.APIM_ENV }}" -u "$APIM_USERNAME" -p "$APIM_PASSWORD" -k --verbose

    echo "üìÅ APIs to deploy:"
    echo "${{ env.DEPLOY_APIS }}"

    # Split DEPLOY_APIS by newline
    IFS=$'\n'
    for api in $DEPLOY_APIS; do
      api=$(echo "$api" | xargs)  # trim spaces
      echo "üöÄ Deploying API: $api"

      if apictl import api \
        -f "${{ env.WORKSPACE }}/release_content/apis/${{ env.APIM_ENV }}/$api" \
        -e "${{ env.APIM_ENV }}" \
        -k \
        --rotate-revision \
        --verbose; then
          echo "‚úÖ Imported $api successfully"
      else
          echo "‚ùå Failed to import $api"
          echo "üîç Error details logged above"
          # Continue to next API
      fi

      sleep 5
    done

===============

# After building VALID_ZIPS
if [ ${#VALID_ZIPS[@]} -eq 0 ]; then
  echo "‚ùå No valid APIs found in release for input!"
  exit 1
fi

# Output newline-separated ZIP files
ZIP_FILES=$(printf "%s\n" "${VALID_ZIPS[@]}")

echo "‚úÖ Final ZIP files to deploy:"
echo "$ZIP_FILES"

{
  echo "zip_files<<EOF"
  echo "$ZIP_FILES"
  echo "EOF"
} >> "$GITHUB_OUTPUT"
